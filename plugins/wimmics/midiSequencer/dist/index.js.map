{
  "version": 3,
  "sources": ["../../sdk/src/WebAudioModule.js", "../../sdk/src/RingBuffer.js", "../../sdk/src/WamArrayRingBuffer.js", "../../sdk/src/WamEnv.js", "../../sdk/src/WamGroup.js", "../../sdk/src/WamEventRingBuffer.js", "../../sdk/src/addFunctionModule.js", "../../sdk/src/WamParameter.js", "../../sdk/src/WamParameterInfo.js", "../../sdk/src/WamParameterInterpolator.js", "../../sdk/src/WamProcessor.js", "../../sdk/src/WamNode.js", "../../sdk/src/apiVersion.js", "../../sdk/src/initializeWamHost.js", "../src/gui.ts", "../src/MidiParser.ts", "../src/MidiSequencerProcessor.ts", "../src/MidiSequencerNode.ts", "../src/index.ts"],
  "sourcesContent": ["/** @typedef {import('@webaudiomodules/api').WamDescriptor} WamDescriptor */\n/** @typedef {import('@webaudiomodules/api').WamNode} WamNode */\n/** @template T @typedef {import('@webaudiomodules/api').WebAudioModule} IWebAudioModule<T> */\n\n/** @implements {IWebAudioModule<WamNode>} */\nclass WebAudioModule {\n\tstatic get isWebAudioModuleConstructor() {\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param {string} groupId\n\t * @param {BaseAudioContext} audioContext\n\t * @param {any} [initialState]\n\t * @returns {Promise<IWebAudioModule<any>>}\n\t */\n\tstatic createInstance(groupId, audioContext, initialState) {\n\t\treturn new this(groupId, audioContext).initialize(initialState);\n\t}\n\n\t/** \n\t * @param {string} groupId\n\t * @param {BaseAudioContext} audioContext \n\t */\n\tconstructor(groupId, audioContext) {\n\t\tthis._groupId = groupId;\n\t\tthis._audioContext = audioContext;\n\t\tthis._initialized = false;\n\t\t/** @type {WamNode} */\n\t\tthis._audioNode = undefined;\n\t\tthis._timestamp = performance.now();\n\t\t/**\n\t\t * Url to load the plugin's GUI HTML\n\t\t * @type {string}\n\t\t */\n\t\tthis._guiModuleUrl = undefined;\n\t\t/**\n\t\t * Url to load the plugin's `descriptor.json`\n\t\t * @type {string}\n\t\t */\n\t\tthis._descriptorUrl = './descriptor.json';\n\t\t/** @type {WamDescriptor} */\n\t\tthis._descriptor = {\n\t\t\tname: `WebAudioModule_${this.constructor.name}`,\n\t\t\tvendor: 'WebAudioModuleVendor',\n\t\t\tdescription: '',\n\t\t\tversion: '0.0.0',\n\t\t\tapiVersion: '2.0.0',\n\t\t\tthumbnail: '',\n\t\t\tkeywords: [],\n\t\t\tisInstrument: false,\n\t\t\twebsite: '',\n\t\t\thasAudioInput: true,\n\t\t\thasAudioOutput: true,\n\t\t\thasAutomationInput: true,\n\t\t\thasAutomationOutput: true,\n\t\t\thasMidiInput: true,\n\t\t\thasMidiOutput: true,\n\t\t\thasMpeInput: true,\n\t\t\thasMpeOutput: true,\n\t\t\thasOscInput: true,\n\t\t\thasOscOutput: true,\n\t\t\thasSysexInput: true,\n\t\t\thasSysexOutput: true,\n\t\t};\n\t}\n\n\tget isWebAudioModule() {\n\t\treturn true;\n\t}\n\n\tget groupId() { return this._groupId; }\n\n\tget moduleId() { return this.vendor + this.name; }\n\n\tget instanceId() { return this.moduleId + this._timestamp; }\n\n\tget descriptor() { return this._descriptor; }\n\n\tget name() { return this.descriptor.name; }\n\n\tget vendor() { return this.descriptor.vendor; }\n\n\tget audioContext() {\n\t\treturn this._audioContext;\n\t}\n\n\tget audioNode() {\n\t\tif (!this.initialized) console.warn('WAM should be initialized before getting the audioNode');\n\t\treturn this._audioNode;\n\t}\n\n\tset audioNode(node) {\n\t\tthis._audioNode = node;\n\t}\n\n\tget initialized() {\n\t\treturn this._initialized;\n\t}\n\n\tset initialized(value) {\n\t\tthis._initialized = value;\n\t}\n\n\t/**\n\t * @param {any} [initialState]\n\t * @returns {Promise<WamNode>}\n\t */\n\tasync createAudioNode(initialState) {\n\t\t// should return a subclass of WamNode\n\t\tthrow new TypeError('createAudioNode() not provided');\n\t}\n\n\t/**\n\t * @param {any} [state]\n\t * @returns {Promise<WebAudioModule>}\n\t */\n\tasync initialize(state) {\n\t\t// await this._loadDescriptor();\n\t\tif (!this._audioNode) this.audioNode = await this.createAudioNode();\n\t\tthis.initialized = true;\n\t\treturn this;\n\t}\n\n\tasync _loadGui() {\n\t\tconst url = this._guiModuleUrl;\n\t\tif (!url) throw new TypeError('Gui module not found');\n\t\t// @ts-ignore\n\t\treturn import(/* webpackIgnore: true */url);\n\t}\n\n\tasync _loadDescriptor() {\n\t\tconst url = this._descriptorUrl;\n\t\tif (!url) throw new TypeError('Descriptor not found');\n\t\tconst response = await fetch(url);\n\t\tconst descriptor = await response.json();\n\t\tObject.assign(this._descriptor, descriptor);\n\t\treturn this._descriptor;\n\t}\n\n\t/**\n\t * @returns {Promise<HTMLElement>}\n\t */\n\tasync createGui() {\n\t\tif (!this.initialized) console.warn('Plugin should be initialized before getting the gui');\n\t\t// Do not fail if no gui is present, just return undefined\n\t\tif (!this._guiModuleUrl) return undefined;\n\t\tconst { createElement } = await this._loadGui();\n\t\treturn createElement(this);\n\t}\n\n\tdestroyGui() {}\n}\n\nexport default WebAudioModule;\n", "/** @typedef {import('@webaudiomodules/api').AudioWorkletGlobalScope} AudioWorkletGlobalScope */\n/** @typedef {import('./types').WamSDKBaseModuleScope} WamSDKBaseModuleScope */\n/** @typedef {import('./types').TypedArrayConstructor} TypedArrayConstructor */\n/** @typedef {import('./types').TypedArray} TypedArray */\n/** @typedef {import('./types').RingBuffer} IRingBuffer */\n/** @typedef {typeof import('./types').RingBuffer} RingBufferConstructor */\n\n/**\n * @param {string} [moduleId]\n * @returns {RingBufferConstructor}\n */\nconst getRingBuffer = (moduleId) => {\n\t/** @type {AudioWorkletGlobalScope} */\n\t// @ts-ignore\n\tconst audioWorkletGlobalScope = globalThis;\n\n\t/**\n\t * A Single Producer - Single Consumer thread-safe wait-free ring buffer.\n\t * The producer and the consumer can be on separate threads, but cannot change roles,\n\t * except with external synchronization. Adapted from https://github.com/padenot/ringbuf.js\n\t * MPL-2.0 License (see RingBuffer_LICENSE.txt)\n\t *\n\t * @implements {IRingBuffer}\n\t * @author padenot\n\t */\n\tclass RingBuffer {\n\t\t/**\n\t\t * @param {number} capacity\n\t\t * @param {TypedArrayConstructor} Type\n\t\t */\n\t\tstatic getStorageForCapacity(capacity, Type) {\n\t\t\tif (!Type.BYTES_PER_ELEMENT) {\n\t\t\t\tthrow new Error('Pass in a ArrayBuffer subclass');\n\t\t\t}\n\t\t\tconst bytes = 8 + (capacity + 1) * Type.BYTES_PER_ELEMENT;\n\t\t\treturn new SharedArrayBuffer(bytes);\n\t\t}\n\n\t\t/**\n\t\t * `sab` is a SharedArrayBuffer with a capacity calculated by calling\n\t\t * `getStorageForCapacity` with the desired capacity.\n\t\t *\n\t\t * @param {SharedArrayBuffer} sab\n\t\t * @param {TypedArrayConstructor} Type\n\t\t */\n\t\tconstructor(sab, Type) {\n\t\t\t// eslint-disable-next-line no-prototype-builtins\n\t\t\tif (!Type.BYTES_PER_ELEMENT) {\n\t\t\t\tthrow new Error('Pass a concrete typed array class as second argument');\n\t\t\t}\n\n\t\t\t// Maximum usable size is 1<<32 - type.BYTES_PER_ELEMENT bytes in the ring\n\t\t\t// buffer for this version, easily changeable.\n\t\t\t// -4 for the write ptr (uint32_t offsets)\n\t\t\t// -4 for the read ptr (uint32_t offsets)\n\t\t\t// capacity counts the empty slot to distinguish between full and empty.\n\t\t\tthis._Type = Type;\n\t\t\tthis._capacity = (sab.byteLength - 8) / Type.BYTES_PER_ELEMENT;\n\t\t\tthis.buf = sab;\n\t\t\tthis.write_ptr = new Uint32Array(this.buf, 0, 1);\n\t\t\tthis.read_ptr = new Uint32Array(this.buf, 4, 1);\n\t\t\tthis.storage = new Type(this.buf, 8, this._capacity);\n\t\t}\n\n\t\t/**\n\t\t * Returns the type of the underlying ArrayBuffer for this RingBuffer. This\n\t\t * allows implementing crude type checking.\n\t\t */\n\t\tget type() {\n\t\t\treturn this._Type.name;\n\t\t}\n\n\t\t/**\n\t\t * Push bytes to the ring buffer. `elements` is a typed array of the same type\n\t\t * as passed in the ctor, to be written to the queue.\n\t\t * Returns the number of elements written to the queue.\n\t\t *\n\t\t * @param {TypedArray} elements\n\t\t */\n\t\tpush(elements) {\n\t\t\tconst rd = Atomics.load(this.read_ptr, 0);\n\t\t\tconst wr = Atomics.load(this.write_ptr, 0);\n\n\t\t\tif ((wr + 1) % this._storageCapacity() === rd) {\n\t\t\t\t// full\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tconst toWrite = Math.min(this._availableWrite(rd, wr), elements.length);\n\t\t\tconst firstPart = Math.min(this._storageCapacity() - wr, toWrite);\n\t\t\tconst secondPart = toWrite - firstPart;\n\n\t\t\tthis._copy(elements, 0, this.storage, wr, firstPart);\n\t\t\tthis._copy(elements, firstPart, this.storage, 0, secondPart);\n\n\t\t\t// publish the enqueued data to the other side\n\t\t\tAtomics.store(\n\t\t\t\tthis.write_ptr,\n\t\t\t\t0,\n\t\t\t\t(wr + toWrite) % this._storageCapacity(),\n\t\t\t);\n\n\t\t\treturn toWrite;\n\t\t}\n\n\t\t/**\n\t\t * Read `elements.length` elements from the ring buffer if `elements` is a typed\n\t\t * array of the same type as passed in the ctor. If `elements` is an integer,\n\t\t * pop and discard that many elements from the ring buffer.\n\t\t * Returns the number of elements read from the queue, they are placed at the\n\t\t * beginning of the array passed as parameter if `elements` is not an integer.\n\t\t *\n\t\t * @param {TypedArray | number} elements\n\t\t */\n\t\tpop(elements) {\n\t\t\tconst rd = Atomics.load(this.read_ptr, 0);\n\t\t\tconst wr = Atomics.load(this.write_ptr, 0);\n\n\t\t\tif (wr === rd) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tconst isArray = !Number.isInteger(elements);\n\t\t\t// @ts-ignore\n\t\t\tconst toRead = Math.min(this._availableRead(rd, wr), isArray ? elements.length : elements);\n\n\t\t\tif (isArray) {\n\t\t\t\tconst firstPart = Math.min(this._storageCapacity() - rd, toRead);\n\t\t\t\tconst secondPart = toRead - firstPart;\n\n\t\t\t\t// @ts-ignore\n\t\t\t\tthis._copy(this.storage, rd, elements, 0, firstPart);\n\t\t\t\t// @ts-ignore\n\t\t\t\tthis._copy(this.storage, 0, elements, firstPart, secondPart);\n\t\t\t}\n\t\t\tAtomics.store(this.read_ptr, 0, (rd + toRead) % this._storageCapacity());\n\n\t\t\treturn toRead;\n\t\t}\n\n\t\t/**\n\t\t * True if the ring buffer is empty false otherwise. This can be late on the\n\t\t * reader side: it can return true even if something has just been pushed.\n\t\t */\n\t\tget empty() {\n\t\t\tconst rd = Atomics.load(this.read_ptr, 0);\n\t\t\tconst wr = Atomics.load(this.write_ptr, 0);\n\n\t\t\treturn wr === rd;\n\t\t}\n\n\t\t/**\n\t\t * True if the ring buffer is full, false otherwise. This can be late on the\n\t\t * write side: it can return true when something has just been popped.\n\t\t */\n\t\tget full() {\n\t\t\tconst rd = Atomics.load(this.read_ptr, 0);\n\t\t\tconst wr = Atomics.load(this.write_ptr, 0);\n\n\t\t\treturn (wr + 1) % this._capacity !== rd;\n\t\t}\n\n\t\t/**\n\t\t * The usable capacity for the ring buffer: the number of elements that can be\n\t\t * stored.\n\t\t */\n\t\tget capacity() {\n\t\t\treturn this._capacity - 1;\n\t\t}\n\n\t\t/**\n\t\t * Number of elements available for reading. This can be late, and report less\n\t\t * elements that is actually in the queue, when something has just been\n\t\t * enqueued.\n\t\t */\n\t\tget availableRead() {\n\t\t\tconst rd = Atomics.load(this.read_ptr, 0);\n\t\t\tconst wr = Atomics.load(this.write_ptr, 0);\n\t\t\treturn this._availableRead(rd, wr);\n\t\t}\n\n\t\t/**\n\t\t * Number of elements available for writing. This can be late, and report less\n\t\t * elements that is actually available for writing, when something has just\n\t\t * been dequeued.\n\t\t */\n\t\tget availableWrite() {\n\t\t\tconst rd = Atomics.load(this.read_ptr, 0);\n\t\t\tconst wr = Atomics.load(this.write_ptr, 0);\n\t\t\treturn this._availableWrite(rd, wr);\n\t\t}\n\n\t\t// private methods //\n\n\t\t/**\n\t\t * Number of elements available for reading, given a read and write pointer..\n\t\t *\n\t\t * @param {number} rd\n\t\t * @param {number} wr\n\t\t */\n\t\t_availableRead(rd, wr) {\n\t\t\tif (wr > rd) {\n\t\t\t\treturn wr - rd;\n\t\t\t}\n\t\t\treturn wr + this._storageCapacity() - rd;\n\t\t}\n\n\t\t/**\n\t\t * Number of elements available from writing, given a read and write pointer.\n\t\t *\n\t\t * @param {number} rd\n\t\t * @param {number} wr\n\t\t */\n\t\t_availableWrite(rd, wr) {\n\t\t\tlet rv = rd - wr - 1;\n\t\t\tif (wr >= rd) {\n\t\t\t\trv += this._storageCapacity();\n\t\t\t}\n\t\t\treturn rv;\n\t\t}\n\n\t\t/**\n\t\t * The size of the storage for elements not accounting the space for the index.\n\t\t */\n\t\t_storageCapacity() {\n\t\t\treturn this._capacity;\n\t\t}\n\n\t\t/**\n\t\t * Copy `size` elements from `input`, starting at offset `offset_input`, to\n\t\t * `output`, starting at offset `offset_output`.\n\t\t *\n\t\t * @param {TypedArray} input\n\t\t * @param {number} offsetInput\n\t\t * @param {TypedArray} output\n\t\t * @param {number} offsetOutput\n\t\t * @param {number} size\n\t\t */\n\t\t_copy(input, offsetInput, output, offsetOutput, size) {\n\t\t\tfor (let i = 0; i < size; i++) {\n\t\t\t\toutput[offsetOutput + i] = input[offsetInput + i];\n\t\t\t}\n\t\t}\n\t}\n\n\tif (audioWorkletGlobalScope.AudioWorkletProcessor) {\n\t\t/** @type {WamSDKBaseModuleScope} */\n\t\tconst ModuleScope = audioWorkletGlobalScope.webAudioModules.getModuleScope(moduleId);\n\n\t\tif (!ModuleScope.RingBuffer) ModuleScope.RingBuffer = RingBuffer;\n\t}\n\n\treturn RingBuffer;\n};\n\nexport default getRingBuffer;\n\n/* Usage in main thread:\nimport executable from 'RingBuffer.js';\nconst RingBuffer = executable();\n*/\n\n/* Usage in audio thread:\n// in main thread:\naudioWorklet.addModule('RingBuffer.js');\n// in audio thread\nconst { RingBuffer } = globalThis;\n*/\n\n/* Usage in audio thread with a build system:\n// in main thread:\nimport getRingBuffer from 'RingBuffer.js';\nconst blob = new Blob([`(${getRingBuffer.toString()})(JSON.stringify(moduleId));`], { type: 'text/javascript' });\nconst url = window.URL.createObjectURL(blob);\naudioWorklet.addModule(url);\n// in audio thread\nconst { RingBuffer } = globalThis.webAudioModules.dependencies[moduleId];\n*/\n", "/** @typedef {import('@webaudiomodules/api').AudioWorkletGlobalScope} AudioWorkletGlobalScope */\n/** @typedef {typeof import('./types').RingBuffer} RingBufferConstructor */\n/** @typedef {import('./types').RingBuffer} RingBuffer */\n/** @typedef {import('./types').TypedArray} TypedArray */\n/** @typedef {import('./types').TypedArrayConstructor} TypedArrayConstructor */\n/** @typedef {import('./types').WamArrayRingBuffer} IWamArrayRingBuffer */\n/** @typedef {typeof import('./types').WamArrayRingBuffer} WamArrayRingBufferConstructor */\n/** @typedef {import('./types').WamSDKBaseModuleScope} WamSDKBaseModuleScope */\n\n/**\n * @param {string} [moduleId]\n * @returns {WamArrayRingBufferConstructor}\n */\nconst getWamArrayRingBuffer = (moduleId) => {\n\t/** @type {AudioWorkletGlobalScope} */\n\t// @ts-ignore\n\tconst audioWorkletGlobalScope = globalThis;\n\n\t/**\n\t * @implements {IWamArrayRingBuffer}\n\t */\n\tclass WamArrayRingBuffer {\n\t\t/**\n\t\t * Default number of arrays for which memory will be allocated.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tstatic DefaultArrayCapacity = 2;\n\n\t\t/**\n\t\t * Returns a SharedArrayBuffer large enough to safely store the\n\t\t * specified number of arrays of the specified length. Specify\n\t\t * `maxArrayCapacity` to support storing more than\n\t\t * `DefaultArrayCapacity` arrays in the buffer.\n\t\t *\n\t\t * @param {RingBufferConstructor} RingBuffer\n\t\t * @param {number} arrayLength\n\t\t * @param {TypedArrayConstructor} arrayType\n\t\t * @param {number} [maxArrayCapacity=undefined]\n\t\t * @returns {SharedArrayBuffer}\n\t\t */\n\t\tstatic getStorageForEventCapacity(RingBuffer, arrayLength, arrayType, maxArrayCapacity = undefined) {\n\t\t\tif (maxArrayCapacity === undefined) maxArrayCapacity = WamArrayRingBuffer.DefaultArrayCapacity;\n\t\t\telse maxArrayCapacity = Math.max(maxArrayCapacity, WamArrayRingBuffer.DefaultArrayCapacity);\n\t\t\tif (!arrayType.BYTES_PER_ELEMENT) {\n\t\t\t\tthrow new Error('Pass in a ArrayBuffer subclass');\n\t\t\t}\n\t\t\tconst capacity = arrayLength * maxArrayCapacity;\n\t\t\treturn RingBuffer.getStorageForCapacity(capacity, arrayType);\n\t\t}\n\n\t\t/**\n\t\t * Provides methods for writing / reading arrays to / from a\n\t\t * RingBuffer. Specify `maxArrayCapacity` to support storing more\n\t \t * than `DefaultArrayCapacity` arrays in the buffer.\n\t\t *\n\t\t * @param {RingBufferConstructor} RingBuffer\n\t\t * @param {SharedArrayBuffer} sab\n\t\t * @param {number} arrayLength\n\t\t * @param {TypedArrayConstructor} arrayType\n\t\t * @param {number} [maxArrayCapacity=undefined]\n\t\t */\n\t\tconstructor(RingBuffer, sab, arrayLength, arrayType, maxArrayCapacity = undefined) {\n\t\t\tif (!arrayType.BYTES_PER_ELEMENT) {\n\t\t\t\tthrow new Error('Pass in a ArrayBuffer subclass');\n\t\t\t}\n\n\t\t\t/** @type {number} */\n\t\t\tthis._arrayLength = arrayLength;\n\n\t\t\t/** @type {TypedArrayConstructor} */\n\t\t\tthis._arrayType = arrayType;\n\n\t\t\t/** @type {number} */\n\t\t\tthis._arrayElementSizeBytes = arrayType.BYTES_PER_ELEMENT;\n\n\t\t\t/** @type {number} */\n\t\t\tthis._arraySizeBytes = this._arrayLength * this._arrayElementSizeBytes;\n\n\t\t\t/** @type {SharedArrayBuffer} */\n\t\t\tthis._sab = sab;\n\n\t\t\tif (maxArrayCapacity === undefined) maxArrayCapacity = WamArrayRingBuffer.DefaultArrayCapacity;\n\t\t\telse maxArrayCapacity = Math.max(maxArrayCapacity, WamArrayRingBuffer.DefaultArrayCapacity);\n\n\t\t\t/** @type {TypedArray} */\n\t\t\tthis._arrayArray = new arrayType(this._arrayLength);\n\n\t\t\t/** @type {RingBuffer} */\n\t\t\tthis._rb = new RingBuffer(this._sab, arrayType);\n\t\t}\n\n\t\t/**\n\t\t * Attempt to write array to the ring buffer, returning whether\n\t\t * or not it was successfully written.\n\t\t *\n\t\t * @param {TypedArray} array\n\t\t * @returns {boolean}\n\t\t */\n\t\twrite(array) {\n\t\t\tif (array.length !== this._arrayLength) return false;\n\t\t\tconst elementsAvailable = this._rb.availableWrite;\n\t\t\tif (elementsAvailable < this._arrayLength) return false;\n\n\t\t\tlet success = true;\n\t\t\tconst elementsWritten = this._rb.push(array);\n\t\t\tif (elementsWritten != this._arrayLength) success = false;\n\t\t\treturn success;\n\t\t}\n\n\t\t/**\n\t\t * Attempt to read array from the ring buffer, returning whether\n\t\t * or not it was successfully read. If `newest` is true, skips\n\t\t * all pending arrays but the most recently written one.\n\t\t *\n\t\t * @param {TypedArray} array\n\t\t * @param {boolean} newest\n\t\t * @returns {boolean}\n\t\t */\n\t\tread(array, newest) {\n\t\t\tif (array.length !== this._arrayLength) return false;\n\t\t\tconst elementsAvailable = this._rb.availableRead;\n\t\t\tif (elementsAvailable < this._arrayLength) return false;\n\n\t\t\t// skip all but most recently written array?\n\t\t\tif (newest && elementsAvailable > this._arrayLength) this._rb.pop(elementsAvailable - this._arrayLength);\n\n\t\t\tlet success = false;\n\t\t\tconst elementsRead = this._rb.pop(array);\n\t\t\tif (elementsRead === this._arrayLength) success = true;\n\t\t\treturn success;\n\t\t}\n\n\t}\n\n\tif (audioWorkletGlobalScope.AudioWorkletProcessor) {\n\t\t/** @type {WamSDKBaseModuleScope} */\n\t\tconst ModuleScope = audioWorkletGlobalScope.webAudioModules.getModuleScope(moduleId);\n\n\t\tif (!ModuleScope.WamArrayRingBuffer) ModuleScope.WamArrayRingBuffer = WamArrayRingBuffer;\n\t}\n\n\treturn WamArrayRingBuffer;\n};\n\nexport default getWamArrayRingBuffer;\n", "/** @typedef {import('@webaudiomodules/api').WamProcessor} IWamProcessor */\n/** @typedef {import('@webaudiomodules/api').WamEnv} IWamEnv */\n/** @typedef {import('@webaudiomodules/api').WamGroup} IWamGroup */\n/** @typedef {import('@webaudiomodules/api').WamEvent} WamEvent */\n/** @typedef {import('@webaudiomodules/api').AudioWorkletGlobalScope} AudioWorkletGlobalScope */\n\n/**\n * @param {string} apiVersion\n */\nconst initializeWamEnv = (apiVersion) => {\n\t/** @type {AudioWorkletGlobalScope} */\n\t// @ts-ignore\n\tconst audioWorkletGlobalScope = globalThis;\n\tif (audioWorkletGlobalScope.AudioWorkletProcessor \n\t\t&& audioWorkletGlobalScope.webAudioModules) return; // already initialized\n\n\t/** @type {Map<string, any>} */\n\tconst moduleScopes = new Map();\n\n\t/** @type {Map<string, IWamGroup>} */\n\tconst groups = new Map();\n\t\n\t/**\n\t * @implements {IWamEnv}\n\t */\n\tclass WamEnv {\n\t\tconstructor() {}\n\n\t\tget apiVersion() {\n\t\t\treturn apiVersion;\n\t\t}\n\n\t\t/**\n\t\t * @param {string} moduleId \n\t\t * @returns {Record<string, any>}\n\t\t*/\n\t\tgetModuleScope(moduleId) {\n\t\t\tif (!moduleScopes.has(moduleId)) moduleScopes.set(moduleId, {});\n\t\t\treturn moduleScopes.get(moduleId);\n\t\t}\n\n\t\t/** \n\t\t * @param {string} groupId\n\t\t * @param {string} groupKey\n\t\t */\n\t\tgetGroup(groupId, groupKey) {\n\t\t\tconst group = groups.get(groupId);\n\t\t\tif (group.validate(groupKey)) return group;\n\t\t\telse throw 'Invalid key';\n\t\t}\n\n\t\t/**\n\t\t * @param {IWamGroup} group\n\t\t */\n\t\taddGroup(group) {\n\t\t\tif (!groups.has(group.groupId)) groups.set(group.groupId, group);\n\t\t}\n\n\t\t/**\n\t\t * @param {IWamGroup} group\n\t\t */\n\t\tremoveGroup(group) {\n\t\t\tgroups.delete(group.groupId);\n\t\t}\n\n\t\t/**\n\t\t * @param {IWamProcessor} wam\n\t\t */\n\t\taddWam(wam) {\n\t\t\t/** @type {IWamGroup} */\n\t\t\tconst group = groups.get(wam.groupId);\n\t\t\tgroup.addWam(wam);\n\t\t}\n\n\t\t/**\n\t\t * @param {IWamProcessor} wam\n\t\t */\n\t\tremoveWam(wam) {\n\t\t\t/** @type {IWamGroup} */\n\t\t\tconst group = groups.get(wam.groupId);\n\t\t\tgroup.removeWam(wam);\n\t\t}\n\n\t\t/**\n\t\t * @param {string} groupId\n\t\t * @param {string} fromId\n\t\t * @param {string} toId\n\t\t * @param {number} [output]\n\t\t */\n\t\tconnectEvents(groupId, fromId, toId, output = 0) {\n\t\t\t/** @type {IWamGroup} */\n\t\t\tconst group = groups.get(groupId);\n\t\t\tgroup.connectEvents(fromId, toId, output);\n\t\t}\n\n\t\t/**\n\t\t * @param {string} groupId\n\t\t * @param {string} fromId\n\t\t * @param {string} [toId]\n\t\t * @param {number} [output]\n\t\t */\n\t\tdisconnectEvents(groupId, fromId, toId, output) {\n\t\t\t/** @type {IWamGroup} */\n\t\t\tconst group = groups.get(groupId);\n\t\t\tgroup.disconnectEvents(fromId, toId, output);\n\t\t}\n\n\t\t/**\n\t\t * @param {IWamProcessor} from\n\t\t * @param {WamEvent[]} events \n\t\t */\n\t\temitEvents(from, ...events) {\n\t\t\t/** @type {IWamGroup} */\n\t\t\tconst group = groups.get(from.groupId);\n\t\t\tgroup.emitEvents(from, ...events);\n\t\t}\n\t}\n\n\tif (audioWorkletGlobalScope.AudioWorkletProcessor) {\n\t\tif (!audioWorkletGlobalScope.webAudioModules) audioWorkletGlobalScope.webAudioModules = new WamEnv();\n\t}\n};\n\nexport default initializeWamEnv;\n", "/** @typedef {import('@webaudiomodules/api').WamProcessor} IWamProcessor */\n/** @typedef {import('@webaudiomodules/api').AudioWorkletGlobalScope} AudioWorkletGlobalScope */\n/** @typedef {import('@webaudiomodules/api').WamEvent} WamEvent */\n/** @typedef {import('./types').WamGroup} IWamGroup */\n\n/**\n * @param {string} groupId\n * @param {string} groupKey\n */\nconst initializeWamGroup = (groupId, groupKey) => {\n\t/** @type {AudioWorkletGlobalScope} */\n\t// @ts-ignore\n\tconst audioWorkletGlobalScope = globalThis;\n\n\t/** @implements IWamGroup */\n\tclass WamGroup {\n\t\t/** \n\t\t * @param {string} groupId\n\t\t * @param {string} groupKey\n\t\t */\n\t\tconstructor(groupId, groupKey) {\n\t\t\t/** @type {string} */\n\t\t\tthis._groupId = groupId;\n\n\t\t\t/** @type {(key: string) => boolean} */\n\t\t\tthis._validate = (key) => {\n\t\t\t\treturn key == groupKey;\n\t\t\t}\n\n\t\t\t/** @type {Map<string, IWamProcessor>} */\n\t\t\tthis._processors = new Map();\n\n\t\t\t/** @type {Map<IWamProcessor, Set<IWamProcessor>[]>} */\n\t\t\tthis._eventGraph = new Map();\n\t\t}\n\n\t\tget groupId() {\n\t\t\treturn this._groupId;\n\t\t}\n\n\t\tget processors() {\n\t\t\treturn this._processors;\n\t\t}\n\n\t\tget eventGraph() {\n\t\t\treturn this._eventGraph;\n\t\t}\n\n\t\tvalidate(groupKey) {\n\t\t\treturn this._validate(groupKey);\n\t\t}\n\n\t\taddWam(wam) {\n\t\t\tthis._processors.set(wam.instanceId, wam);\n\t\t}\n\n\t\tremoveWam(wam) {\n\t\t\tif (this._eventGraph.has(wam)) this._eventGraph.delete(wam);\n\t\t\tthis._eventGraph.forEach((outputMap) => {\n\t\t\t\toutputMap.forEach((set) => {\n\t\t\t\t\tif (set && set.has(wam)) set.delete(wam);\n\t\t\t\t});\n\t\t\t});\n\t\t\tthis._processors.delete(wam.instanceId);\n\t\t}\n\t\n\t\t/**\n\t\t * @param {string} fromId\n\t\t * @param {string} toId\n\t\t * @param {number} [output]\n\t\t */\n\t\tconnectEvents(fromId, toId, output) {\n\t\t\t/** @type {IWamProcessor} */\n\t\t\tconst from = this._processors.get(fromId);\n\t\t\t/** @type {IWamProcessor} */\n\t\t\tconst to = this._processors.get(toId);\n\n\t\t\t/** @type {Set<IWamProcessor>[]} */\n\t\t\tlet outputMap;\n\t\t\tif (this._eventGraph.has(from)) {\n\t\t\t\toutputMap = this._eventGraph.get(from);\n\t\t\t} else {\n\t\t\t\toutputMap = [];\n\t\t\t\tthis._eventGraph.set(from, outputMap);\n\t\t\t}\n\t\t\tif (outputMap[output]) {\n\t\t\t\toutputMap[output].add(to);\n\t\t\t} else {\n\t\t\t\tconst set = new Set();\n\t\t\t\tset.add(to);\n\t\t\t\toutputMap[output] = set;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @param {string} fromId\n\t\t * @param {string} [toId]\n\t\t * @param {number} [output]\n\t\t */\n\t\tdisconnectEvents(fromId, toId, output) {\n\t\t\t/** @type {IWamProcessor} */\n\t\t\tconst from = this._processors.get(fromId);\n\t\t\t\n\t\t\tif (!this._eventGraph.has(from)) return;\n\t\t\tconst outputMap = this._eventGraph.get(from);\n\t\t\tif (typeof toId === 'undefined') {\n\t\t\t\toutputMap.forEach((set) => {\n\t\t\t\t\tif (set) set.clear();\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t} \n\t\t\t\n\t\t\t/** @type {IWamProcessor} */\n\t\t\tconst to = this._processors.get(toId);\n\n\t\t\tif (typeof output === 'undefined') {\n\t\t\t\toutputMap.forEach((set) => {\n\t\t\t\t\tif (set) set.delete(to);\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!outputMap[output]) return;\n\t\t\toutputMap[output].delete(to);\n\t\t}\n\n\t\t/**\n\t\t * @param {IWamProcessor} from\n\t\t * @param {WamEvent[]} events \n\t\t */\n\t\temitEvents(from, ...events) {\n\t\t\tif (!this._eventGraph.has(from)) return;\n\t\t\tconst downstream = this._eventGraph.get(from);\n\t\t\tdownstream.forEach((set) => {\n\t\t\t\tif (set) set.forEach((wam) => wam.scheduleEvents(...events));\n\t\t\t});\n\t\t}\n\t}\n\n\tif (audioWorkletGlobalScope.AudioWorkletProcessor) {\n\t\taudioWorkletGlobalScope.webAudioModules.addGroup(new WamGroup(groupId, groupKey));\n\t}\n};\n\nexport default initializeWamGroup;\n", "/** @typedef {import('@webaudiomodules/api').WamEvent} WamEvent */\n/** @typedef {import('@webaudiomodules/api').WamEventType} WamEventType */\n/** @typedef {import('@webaudiomodules/api').WamAutomationEvent} WamAutomationEvent */\n/** @typedef {import('@webaudiomodules/api').WamTransportEvent} WamTransportEvent */\n/** @typedef {import('@webaudiomodules/api').WamMidiEvent} WamMidiEvent */\n/** @typedef {import('@webaudiomodules/api').WamSysexEvent} WamSysexEvent */\n/** @typedef {import('@webaudiomodules/api').WamMpeEvent} WamMpeEvent */\n/** @typedef {import('@webaudiomodules/api').WamOscEvent} WamOscEvent */\n/** @typedef {import('@webaudiomodules/api').WamInfoEvent} WamInfoEvent */\n/** @typedef {import('@webaudiomodules/api').WamParameterData} WamParameterData */\n/** @typedef {import('@webaudiomodules/api').WamTransportData} WamTransportData */\n/** @typedef {import('@webaudiomodules/api').WamMidiData} WamMidiData */\n/** @typedef {import('@webaudiomodules/api').WamBinaryData} WamBinaryData */\n/** @typedef {import('@webaudiomodules/api').WamInfoData} WamInfoData */\n/** @typedef {import('@webaudiomodules/api').AudioWorkletGlobalScope} AudioWorkletGlobalScope */\n/** @typedef {typeof import('./types').RingBuffer} RingBufferConstructor */\n/** @typedef {import('./types').RingBuffer} RingBuffer */\n/** @typedef {import('./types').TypedArrayConstructor} TypedArrayConstructor */\n/** @typedef {import('./types').WamEventRingBuffer} IWamEventRingBuffer */\n/** @typedef {typeof import('./types').WamEventRingBuffer} WamEventRingBufferConstructor */\n/** @typedef {import('./types').WamSDKBaseModuleScope} WamSDKBaseModuleScope */\n\n/**\n * @param {string} [moduleId]\n * @returns {WamEventRingBufferConstructor}\n */\nconst getWamEventRingBuffer = (moduleId) => {\n\t/** @type {AudioWorkletGlobalScope} */\n\t// @ts-ignore\n\tconst audioWorkletGlobalScope = globalThis;\n\n\t/**\n\t * @implements {IWamEventRingBuffer}\n\t */\n\tclass WamEventRingBuffer {\n\n\t\t/**\n\t\t * Default number of additional bytes allocated\n\t\t * per event (to support variable-size event objects)\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tstatic DefaultExtraBytesPerEvent = 64;\n\n\t\t/**\n\t\t * Number of bytes required for WamEventBase\n\t\t * {uint32} total event size in bytes\n\t\t * {uint8} encoded event type\n\t\t * {float64} time\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tstatic WamEventBaseBytes = 4 + 1 + 8;\n\n\t\t/**\n\t\t * Number of bytes required for WamAutomationEvent\n\t\t * {WamEventBaseBytes} common event properties\n\t\t * {uint16} encoded parameter id\n\t\t * {float64} value\n\t\t * {uint8} normalized\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tstatic WamAutomationEventBytes = WamEventRingBuffer.WamEventBaseBytes + 2 + 8 + 1;\n\n\t\t/**\n\t\t * Number of bytes required for WamTransportEvent\n\t\t * {WamEventBaseBytes} common event properties\n\t\t * {uint32} current bar\n\t\t * {float64} currentBarStarted\n\t\t * {float64} tempo\n\t\t * {uint8} time signature numerator\n\t\t * {uint8} time signature denominator\n\t\t * {uint8} playing flag\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tstatic WamTransportEventBytes = WamEventRingBuffer.WamEventBaseBytes + 4 + 8 + 8 + 1 + 1 + 1;\n\n\t\t/**\n\t\t * Number of bytes required for WamMidiEvent or WamMpeEvent\n\t\t * {WamEventBaseBytes} common event properties\n\t\t * {uint8} status byte\n\t\t * {uint8} data1 byte\n\t\t * {uint8} data2 byte\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tstatic WamMidiEventBytes = WamEventRingBuffer.WamEventBaseBytes + 1 + 1 + 1;\n\n\t\t/**\n\t\t * Number of bytes required for WamSysexEvent or WamOscEvent\n\t\t * (total number depends on content of message / size of byte array)\n\t\t * {WamEventBaseBytes} common event properties\n\t\t * {uint32} number of bytes in binary array\n\t\t * {uint8[]} N bytes in binary array depending on message\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tstatic WamBinaryEventBytes = WamEventRingBuffer.WamEventBaseBytes + 4; // + N\n\n\t\t/**\n\t\t * Returns a SharedArrayBuffer large enough to safely store\n\t\t * the specified number of events. Specify 'maxBytesPerEvent'\n\t\t * to support variable-size binary event types like sysex or osc.\n\t\t *\n\t\t * @param {RingBufferConstructor} RingBuffer\n\t\t * @param {number} eventCapacity\n\t\t * @param {number} [maxBytesPerEvent=undefined]\n\t\t * @returns {SharedArrayBuffer}\n\t\t */\n\t\tstatic getStorageForEventCapacity(RingBuffer, eventCapacity, maxBytesPerEvent = undefined) {\n\t\t\tif (maxBytesPerEvent === undefined) maxBytesPerEvent = WamEventRingBuffer.DefaultExtraBytesPerEvent;\n\t\t\telse maxBytesPerEvent = Math.max(maxBytesPerEvent, WamEventRingBuffer.DefaultExtraBytesPerEvent);\n\t\t\tconst capacity = (Math.max(\n\t\t\t\tWamEventRingBuffer.WamAutomationEventBytes,\n\t\t\t\tWamEventRingBuffer.WamTransportEventBytes,\n\t\t\t\tWamEventRingBuffer.WamMidiEventBytes,\n\t\t\t\tWamEventRingBuffer.WamBinaryEventBytes,\n\t\t\t) + maxBytesPerEvent) * eventCapacity;\n\t\t\treturn RingBuffer.getStorageForCapacity(capacity, Uint8Array);\n\t\t}\n\n\t\t/**\n\t\t * Provides methods for encoding / decoding WamEvents to / from\n\t\t * a UInt8Array RingBuffer. Specify 'maxBytesPerEvent'\n\t\t * to support variable-size binary event types like sysex or osc.\n\t\t *\n\t\t * @param {RingBufferConstructor} RingBuffer\n\t\t * @param {SharedArrayBuffer} sab\n\t\t * @param {string[]} parameterIds\n\t\t * @param {number} [maxBytesPerEvent=undefined]\n\t\t */\n\t\tconstructor(RingBuffer, sab, parameterIds, maxBytesPerEvent = undefined) {\n\t\t\t/** @type {Record<string, number>} */\n\t\t\tthis._eventSizeBytes = {};\n\n\t\t\t/** @type {Record<string, number>} */\n\t\t\tthis._encodeEventType = {};\n\n\t\t\t/** @type {Record<number, string>} */\n\t\t\tthis._decodeEventType = {};\n\t\t\t/** @type {WamEventType[]} */\n\t\t\tconst wamEventTypes = ['wam-automation', 'wam-transport', 'wam-midi', 'wam-sysex', 'wam-mpe', 'wam-osc', 'wam-info'];\n\t\t\twamEventTypes.forEach((type, encodedType) => {\n\t\t\t\tlet byteSize = 0;\n\t\t\t\tswitch (type) {\n\t\t\t\tcase 'wam-automation': byteSize = WamEventRingBuffer.WamAutomationEventBytes; break;\n\t\t\t\tcase 'wam-transport': byteSize = WamEventRingBuffer.WamTransportEventBytes; break;\n\t\t\t\tcase 'wam-mpe':\n\t\t\t\tcase 'wam-midi': byteSize = WamEventRingBuffer.WamMidiEventBytes; break;\n\t\t\t\tcase 'wam-osc':\n\t\t\t\tcase 'wam-sysex':\n\t\t\t\tcase 'wam-info': byteSize = WamEventRingBuffer.WamBinaryEventBytes; break;\n\t\t\t\tdefault: break;\n\t\t\t\t}\n\t\t\t\tthis._eventSizeBytes[type] = byteSize;\n\t\t\t\tthis._encodeEventType[type] = encodedType;\n\t\t\t\tthis._decodeEventType[encodedType] = type;\n\t\t\t});\n\n\t\t\t/** @type {number} */\n\t\t\tthis._parameterCode = 0;\n\t\t\t/** @type {{[parameterId: string]: number}} */\n\t\t\tthis._parameterCodes = {};\n\t\t\t/** @type {{[parameterId: string]: number}} */\n\t\t\tthis._encodeParameterId = {};\n\t\t\t/** @type {{[parameterId: number]: string}} */\n\t\t\tthis._decodeParameterId = {};\n\t\t\tthis.setParameterIds(parameterIds);\n\n\t\t\t/** @type {SharedArrayBuffer} */\n\t\t\tthis._sab = sab;\n\n\t\t\tif (maxBytesPerEvent === undefined) maxBytesPerEvent = WamEventRingBuffer.DefaultExtraBytesPerEvent;\n\t\t\telse maxBytesPerEvent = Math.max(maxBytesPerEvent, WamEventRingBuffer.DefaultExtraBytesPerEvent);\n\n\t\t\t/** @type {number} */\n\t\t\tthis._eventBytesAvailable = Math.max(\n\t\t\t\tWamEventRingBuffer.WamAutomationEventBytes,\n\t\t\t\tWamEventRingBuffer.WamTransportEventBytes,\n\t\t\t\tWamEventRingBuffer.WamMidiEventBytes,\n\t\t\t\tWamEventRingBuffer.WamBinaryEventBytes,\n\t\t\t) + maxBytesPerEvent;\n\t\t\t/** @type {ArrayBuffer} */\n\t\t\tthis._eventBytes = new ArrayBuffer(this._eventBytesAvailable);\n\t\t\t/** @type {DataView} */\n\t\t\tthis._eventBytesView = new DataView(this._eventBytes);\n\n\t\t\t/** @type {RingBuffer} */\n\t\t\tthis._rb = new RingBuffer(this._sab, Uint8Array);\n\n\t\t\t/** @type {Uint8Array} */\n\t\t\tthis._eventSizeArray = new Uint8Array(this._eventBytes, 0, 4);\n\n\t\t\t/** @type {DataView} */\n\t\t\tthis._eventSizeView = new DataView(this._eventBytes, 0, 4);\n\t\t}\n\n\t\t/**\n\t\t * Write common WamEvent properties to internal buffer.\n\t\t *\n\t\t * @private\n\t\t * @param {number} byteSize total size of event in bytes\n\t\t * @param {string} type\n\t\t * @param {number} time\n\t\t * @returns {number} updated byte offset\n\t\t */\n\t\t_writeHeader(byteSize, type, time) {\n\t\t\tlet byteOffset = 0;\n\t\t\tthis._eventBytesView.setUint32(byteOffset, byteSize);\n\t\t\tbyteOffset += 4;\n\t\t\tthis._eventBytesView.setUint8(byteOffset, this._encodeEventType[type]);\n\t\t\tbyteOffset += 1;\n\t\t\tthis._eventBytesView.setFloat64(byteOffset, Number.isFinite(time) ? time : -1);\n\t\t\tbyteOffset += 8;\n\t\t\treturn byteOffset;\n\t\t}\n\n\t\t/**\n\t\t * Write WamEvent to internal buffer.\n\t\t *\n\t\t * @private\n\t\t * @param {WamEvent} event\n\t\t * @returns {Uint8Array}\n\t\t */\n\t\t_encode(event) {\n\t\t\tlet byteOffset = 0;\n\t\t\tconst { type, time } = event;\n\t\t\tswitch (event.type) {\n\t\t\tcase 'wam-automation': {\n\t\t\t\tif (!(event.data.id in this._encodeParameterId)) break;\n\t\t\t\tconst byteSize = this._eventSizeBytes[type];\n\t\t\t\tbyteOffset = this._writeHeader(byteSize, type, time);\n\n\t\t\t\t/**\n\t\t\t\t * @type {WamAutomationEvent}\n\t\t\t\t * @property {WamAutomationData} data\n\t\t\t\t */\n\t\t\t\tconst { data } = event;\n\t\t\t\tconst encodedParameterId = this._encodeParameterId[data.id];\n\t\t\t\tconst { value, normalized } = data;\n\n\t\t\t\tthis._eventBytesView.setUint16(byteOffset, encodedParameterId);\n\t\t\t\tbyteOffset += 2;\n\t\t\t\tthis._eventBytesView.setFloat64(byteOffset, value);\n\t\t\t\tbyteOffset += 8;\n\t\t\t\tthis._eventBytesView.setUint8(byteOffset, normalized ? 1 : 0);\n\t\t\t\tbyteOffset += 1;\n\t\t\t} break;\n\t\t\tcase 'wam-transport': {\n\t\t\t\tconst byteSize = this._eventSizeBytes[type];\n\t\t\t\tbyteOffset = this._writeHeader(byteSize, type, time);\n\n\t\t\t\t/**\n\t\t\t\t * @type {WamTransportEvent}\n\t\t\t\t * @property {WamTransportData} data\n\t\t\t\t */\n\t\t\t\tconst { data } = event;\n\t\t\t\tconst {\n\t\t\t\t\tcurrentBar, currentBarStarted, tempo, timeSigNumerator, timeSigDenominator, playing\n\t\t\t\t} = data;\n\n\t\t\t\tthis._eventBytesView.setUint32(byteOffset, currentBar);\n\t\t\t\tbyteOffset += 4;\n\t\t\t\tthis._eventBytesView.setFloat64(byteOffset, currentBarStarted);\n\t\t\t\tbyteOffset += 8;\n\t\t\t\tthis._eventBytesView.setFloat64(byteOffset, tempo);\n\t\t\t\tbyteOffset += 8;\n\t\t\t\tthis._eventBytesView.setUint8(byteOffset, timeSigNumerator);\n\t\t\t\tbyteOffset += 1;\n\t\t\t\tthis._eventBytesView.setUint8(byteOffset, timeSigDenominator);\n\t\t\t\tbyteOffset += 1;\n\t\t\t\tthis._eventBytesView.setUint8(byteOffset, playing ? 1 : 0);\n\t\t\t\tbyteOffset += 1;\n\t\t\t} break;\n\t\t\tcase 'wam-mpe':\n\t\t\tcase 'wam-midi': {\n\t\t\t\tconst byteSize = this._eventSizeBytes[type];\n\t\t\t\tbyteOffset = this._writeHeader(byteSize, type, time);\n\n\t\t\t\t/**\n\t\t\t\t * @type {WamMidiEvent | WamMpeEvent}\n\t\t\t\t * @property {WamMidiData} data\n\t\t\t\t */\n\t\t\t\tconst { data } = event;\n\t\t\t\tconst { bytes } = data;\n\t\t\t\tlet b = 0;\n\t\t\t\twhile (b < 3) {\n\t\t\t\t\tthis._eventBytesView.setUint8(byteOffset, bytes[b]);\n\t\t\t\t\tbyteOffset += 1;\n\t\t\t\t\tb++;\n\t\t\t\t}\n\t\t\t} break;\n\t\t\tcase 'wam-osc':\n\t\t\tcase 'wam-sysex':\n\t\t\tcase 'wam-info': {\n\t\t\t\t/** @type {Uint8Array | null} */\n\t\t\t\tlet bytes = null;\n\t\t\t\tif (event.type === 'wam-info') {\n\t\t\t\t\t/**\n\t\t\t\t\t * @type {WamInfoEvent}\n\t\t\t\t\t * @property {WamInfoData} data\n\t\t\t\t\t */\n\t\t\t\t\tconst { data } = event;\n\t\t\t\t\tbytes = (new TextEncoder()).encode(data.instanceId);\n\t\t\t\t} else {\n\t\t\t\t\t/**\n\t\t\t\t\t * @type {WamSysexEvent | WamOscEvent}\n\t\t\t\t\t * @property {WamBinaryData} data\n\t\t\t\t\t */\n\t\t\t\t\tconst { data } = event;\n\t\t\t\t\tbytes = data.bytes;\n\t\t\t\t}\n\t\t\t\tconst numBytes = bytes.length;\n\t\t\t\tconst byteSize = this._eventSizeBytes[type];\n\t\t\t\tbyteOffset = this._writeHeader(byteSize + numBytes, type, time);\n\n\t\t\t\tthis._eventBytesView.setUint32(byteOffset, numBytes);\n\t\t\t\tbyteOffset += 4;\n\n\t\t\t\tconst bytesRequired = byteOffset + numBytes;\n\t\t\t\t// eslint-disable-next-line no-console\n\t\t\t\tif (bytesRequired > this._eventBytesAvailable) console.error(`Event requires ${bytesRequired} bytes but only ${this._eventBytesAvailable} have been allocated!`);\n\n\t\t\t\tconst buffer = new Uint8Array(this._eventBytes, byteOffset, numBytes);\n\t\t\t\tbuffer.set(bytes);\n\t\t\t\tbyteOffset += numBytes;\n\t\t\t} break;\n\t\t\tdefault: break;\n\t\t\t}\n\t\t\treturn new Uint8Array(this._eventBytes, 0, byteOffset);\n\t\t}\n\n\t\t/**\n\t\t * Read WamEvent from internal buffer.\n\t\t *\n\t\t * @private\n\t\t * @returns {WamEvent | false} Decoded WamEvent\n\t\t */\n\t\t_decode() {\n\t\t\tlet byteOffset = 0;\n\t\t\tconst type = this._decodeEventType[this._eventBytesView.getUint8(byteOffset)];\n\t\t\tbyteOffset += 1;\n\t\t\tlet time = this._eventBytesView.getFloat64(byteOffset);\n\t\t\tif (time === -1) time = undefined;\n\t\t\tbyteOffset += 8;\n\n\t\t\tswitch (type) {\n\t\t\tcase 'wam-automation': {\n\t\t\t\tconst encodedParameterId = this._eventBytesView.getUint16(byteOffset);\n\t\t\t\tbyteOffset += 2;\n\t\t\t\tconst value = this._eventBytesView.getFloat64(byteOffset);\n\t\t\t\tbyteOffset += 8;\n\t\t\t\tconst normalized = !!this._eventBytesView.getUint8(byteOffset);\n\t\t\t\tbyteOffset += 1;\n\n\t\t\t\tif (!(encodedParameterId in this._decodeParameterId)) break;\n\t\t\t\tconst id = this._decodeParameterId[encodedParameterId];\n\t\t\t\t/** @type {WamAutomationEvent} */\n\t\t\t\tconst event = {\n\t\t\t\t\ttype,\n\t\t\t\t\ttime,\n\t\t\t\t\tdata: {\n\t\t\t\t\t\tid, value, normalized,\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t\treturn event;\n\t\t\t}\n\t\t\tcase 'wam-transport': {\n\t\t\t\tconst currentBar = this._eventBytesView.getUint32(byteOffset);\n\t\t\t\tbyteOffset += 4;\n\t\t\t\tconst currentBarStarted = this._eventBytesView.getFloat64(byteOffset);\n\t\t\t\tbyteOffset += 8;\n\t\t\t\tconst tempo = this._eventBytesView.getFloat64(byteOffset);\n\t\t\t\tbyteOffset += 8;\n\t\t\t\tconst timeSigNumerator = this._eventBytesView.getUint8(byteOffset);\n\t\t\t\tbyteOffset += 1;\n\t\t\t\tconst timeSigDenominator = this._eventBytesView.getUint8(byteOffset);\n\t\t\t\tbyteOffset += 1;\n\t\t\t\tconst playing = (this._eventBytesView.getUint8(byteOffset) == 1);\n\t\t\t\tbyteOffset += 1;\n\n\t\t\t\t/** @type {WamTransportEvent} */\n\t\t\t\tconst event = {\n\t\t\t\t\ttype,\n\t\t\t\t\ttime,\n\t\t\t\t\tdata: {\n\t\t\t\t\t\tcurrentBar, currentBarStarted, tempo, timeSigNumerator, timeSigDenominator, playing\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t\treturn event;\n\t\t\t}\n\t\t\tcase 'wam-mpe':\n\t\t\tcase 'wam-midi': {\n\t\t\t\t/** @type {[number, number, number]} */\n\t\t\t\tconst bytes = [0, 0, 0];\n\t\t\t\tlet b = 0;\n\t\t\t\twhile (b < 3) {\n\t\t\t\t\tbytes[b] = this._eventBytesView.getUint8(byteOffset);\n\t\t\t\t\tbyteOffset += 1;\n\t\t\t\t\tb++;\n\t\t\t\t}\n\n\t\t\t\t/** @type {WamMidiEvent | WamMpeEvent} */\n\t\t\t\tconst event = {\n\t\t\t\t\ttype,\n\t\t\t\t\ttime,\n\t\t\t\t\tdata: { bytes },\n\t\t\t\t};\n\t\t\t\treturn event;\n\t\t\t}\n\t\t\tcase 'wam-osc':\n\t\t\tcase 'wam-sysex':\n\t\t\tcase 'wam-info': {\n\t\t\t\tconst numBytes = this._eventBytesView.getUint32(byteOffset);\n\t\t\t\tbyteOffset += 4;\n\t\t\t\tconst bytes = new Uint8Array(numBytes);\n\t\t\t\tbytes.set(new Uint8Array(this._eventBytes, byteOffset, numBytes));\n\t\t\t\tbyteOffset += numBytes;\n\n\t\t\t\tif (type === 'wam-info') {\n\t\t\t\t\tconst instanceId = (new TextDecoder()).decode(bytes);\n\t\t\t\t\tconst data = { instanceId };\n\t\t\t\t\treturn { type, time, data };\n\t\t\t\t} else {\n\t\t\t\t\tconst data = { bytes };\n\t\t\t\t\treturn { type, time, data };\n\t\t\t\t}\n\t\t\t}\n\t\t\tdefault: break;\n\t\t\t}\n\t\t\t// eslint-disable-next-line no-console\n\t\t\t// console.warn('Failed to decode event!');\n\t\t\treturn false;\n\t\t}\n\n\t\t/**\n\t\t * Write WamEvents to the ring buffer, returning\n\t\t * the number of events successfully written.\n\t\t *\n\t\t * @param {WamEvent[]} events\n\t\t * @returns {number}\n\t\t */\n\t\twrite(...events) {\n\t\t\tconst numEvents = events.length;\n\t\t\tlet bytesAvailable = this._rb.availableWrite;\n\t\t\tlet numSkipped = 0;\n\t\t\tlet i = 0;\n\t\t\twhile (i < numEvents) {\n\t\t\t\tconst event = events[i];\n\t\t\t\tconst bytes = this._encode(event);\n\t\t\t\tconst eventSizeBytes = bytes.byteLength;\n\n\t\t\t\tlet bytesWritten = 0;\n\t\t\t\tif (bytesAvailable >= eventSizeBytes) {\n\t\t\t\t\tif (eventSizeBytes === 0) numSkipped++;\n\t\t\t\t\telse bytesWritten = this._rb.push(bytes);\n\t\t\t\t} else break;\n\t\t\t\tbytesAvailable -= bytesWritten;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\treturn i - numSkipped;\n\t\t}\n\n\t\t/**\n\t\t * Read WamEvents from the ring buffer, returning\n\t\t * the list of events successfully read.\n\t\t *\n\t\t * @returns {WamEvent[]}\n\t\t */\n\t\tread() {\n\t\t\tif (this._rb.empty) return [];\n\t\t\tconst events = [];\n\t\t\tlet bytesAvailable = this._rb.availableRead;\n\t\t\tlet bytesRead = 0;\n\t\t\twhile (bytesAvailable > 0) {\n\t\t\t\tbytesRead = this._rb.pop(this._eventSizeArray);\n\t\t\t\tbytesAvailable -= bytesRead;\n\t\t\t\tconst eventSizeBytes = this._eventSizeView.getUint32(0);\n\t\t\t\tconst eventBytes = new Uint8Array(this._eventBytes, 0, eventSizeBytes - 4);\n\t\t\t\tbytesRead = this._rb.pop(eventBytes);\n\t\t\t\tbytesAvailable -= bytesRead;\n\t\t\t\tconst decodedEvent = this._decode();\n\t\t\t\tif (decodedEvent) events.push(decodedEvent);\n\t\t\t}\n\t\t\treturn events;\n\t\t}\n\n\t\t/**\n\t\t * In case parameter set changes, update the internal mappings.\n\t\t * May result in some invalid automation events, which will be\n\t \t * ignored. Note that this must be called on all corresponding\n\t\t * WamEventRingBuffers on both threads.\n\t\t * @param {string[]} parameterIds\n\t\t */\n\t\tsetParameterIds(parameterIds) {\n\t\t\tthis._encodeParameterId = {};\n\t\t\tthis._decodeParameterId = {};\n\t\t\tparameterIds.forEach((parameterId) => {\n\t\t\t\tlet parameterCode = -1\n\t\t\t\tif (parameterId in this._parameterCodes) parameterCode = this._parameterCodes[parameterId];\n\t\t\t\telse {\n\t\t\t\t\tparameterCode = this._generateParameterCode();\n\t\t\t\t\tthis._parameterCodes[parameterId] = parameterCode;\n\t\t\t\t}\n\t\t\t\tthis._encodeParameterId[parameterId] = parameterCode;\n\t\t\t\tthis._decodeParameterId[parameterCode] = parameterId;\n\t\t\t});\n\t\t}\n\n\t\t/**\n\t\t * Generates a numeric parameter code in a range suitable for\n\t\t * encoding as uint16.\n\t\t *\n\t\t * @returns {number}\n\t\t */\n\t\t_generateParameterCode() {\n\t\t\tif (this._parameterCode > 65535) throw Error('Too many parameters have been registered!');\n\t\t\treturn this._parameterCode++;\n\t\t}\n\n\t}\n\n\tif (audioWorkletGlobalScope.AudioWorkletProcessor) {\n\t\t/** @type {WamSDKBaseModuleScope} */\n\t\tconst ModuleScope = audioWorkletGlobalScope.webAudioModules.getModuleScope(moduleId);\n\n\t\tif (!ModuleScope.WamEventRingBuffer) ModuleScope.WamEventRingBuffer = WamEventRingBuffer;\n\t}\n\n\treturn WamEventRingBuffer;\n};\n\nexport default getWamEventRingBuffer;\n", "/**\r\n * Take a function, stringify it and inject to an AudioWorklet with parameters.\r\n *\r\n * @param {AudioWorklet} audioWorklet\r\n * @param {(...args: any[]) => any} processorFunction\r\n * @param {any[]} [injection]\r\n * @returns {Promise<void>}\r\n */\r\nconst addFunctionModule = (audioWorklet, processorFunction, ...injection) => {\r\n    const text = `(${processorFunction.toString()})(${injection.map((s) => JSON.stringify(s)).join(', ')});`\r\n    const url = URL.createObjectURL(new Blob([text], { type: 'text/javascript' }));\r\n    return audioWorklet.addModule(url);\r\n}\r\n\r\nexport default addFunctionModule;\r\n", "/** @typedef {import('@webaudiomodules/api').WamParameter} IWamParameter */\n/** @typedef {typeof import('@webaudiomodules/api').WamParameter} WamParameterContructor */\n/** @typedef {import('@webaudiomodules/api').WamParameterInfo} WamParameterInfo */\n/** @typedef {import('@webaudiomodules/api').AudioWorkletGlobalScope} AudioWorkletGlobalScope */\n/** @typedef {import('./types').WamSDKBaseModuleScope} WamSDKBaseModuleScope */\n\n/**\n * @param {string} [moduleId]\n * @returns {WamParameterContructor}\n */\nconst getWamParameter = (moduleId) => {\n\t/** @type {AudioWorkletGlobalScope} */\n\t// @ts-ignore\n\tconst audioWorkletGlobalScope = globalThis;\n\n\t/** @implements {IWamParameter} */\n\tclass WamParameter {\n\t\t/** @param {WamParameterInfo} info */\n\t\tconstructor(info) {\n\t\t\t/** @readonly @type {WamParameterInfo} */\n\t\t\tthis.info = info;\n\t\t\t/** @private @type {number} */\n\t\t\tthis._value = info.defaultValue;\n\t\t}\n\t\n\t\t/**\n\t\t * Set current (denormalized) value\n\t\t * @param {number} value\n\t\t*/\n\t\tset value(value) {\n\t\t\tthis._value = value;\n\t\t}\n\t\n\t\t/**\n\t\t * Get current (denormalized) value\n\t\t * @returns {number}\n\t\t */\n\t\tget value() {\n\t\t\treturn this._value;\n\t\t}\n\t\n\t\t/**\n\t\t * Set current value in normalized range\n\t\t * @param {number} valueNorm\n\t\t */\n\t\tset normalizedValue(valueNorm) {\n\t\t\tthis.value = this.info.denormalize(valueNorm);\n\t\t}\n\t\n\t\t/**\n\t\t * Get current value in normalized range\n\t\t * @returns {number}\n\t\t */\n\t\tget normalizedValue() {\n\t\t\treturn this.info.normalize(this.value);\n\t\t}\n\t}\n\n\tif (audioWorkletGlobalScope.AudioWorkletProcessor) {\n\t\t/** @type {WamSDKBaseModuleScope} */\n\t\tconst ModuleScope = audioWorkletGlobalScope.webAudioModules.getModuleScope(moduleId);\n\t\n\t\tif (!ModuleScope.WamParameter) ModuleScope.WamParameter = WamParameter;\n\t}\n\n\treturn WamParameter;\n};\n\nexport default getWamParameter;\n", "/** @typedef {import('@webaudiomodules/api').WamParameterInfo} IWamParameterInfo */\n/** @typedef {typeof import('@webaudiomodules/api').WamParameterInfo} WamParameterInfoConstructor */\n/** @typedef {import('@webaudiomodules/api').WamParameterType} WamParameterType */\n/** @typedef {import('@webaudiomodules/api').WamParameterConfiguration} WamParameterConfiguration */\n/** @typedef {import('@webaudiomodules/api').AudioWorkletGlobalScope} AudioWorkletGlobalScope */\n/** @typedef {import('./types').WamSDKBaseModuleScope} WamSDKBaseModuleScope */\n\n/**\n * @param {string} [moduleId]\n * @returns {WamParameterInfoConstructor}\n */\nconst getWamParameterInfo = (moduleId) => {\n\t/** @type {AudioWorkletGlobalScope} */\n\t// @ts-ignore\n\tconst audioWorkletGlobalScope = globalThis;\n\n\t/**\n\t * @param {number} x\n\t * @param {number} e\n\t */\n\tconst normExp = (x, e) => (e === 0 ? x : x ** (1.5 ** -e));\n\t\n\t/**\n\t * @param {number} x\n\t * @param {number} e\n\t */\n\tconst denormExp = (x, e) => (e === 0 ? x : x ** (1.5 ** e));\n\t\n\t/**\n\t * @param {number} x\n\t * @param {number} min\n\t * @param {number} max\n\t */\n\tconst normalize = (x, min, max, e = 0) => (\n\t\tmin === 0 && max === 1\n\t\t\t? normExp(x, e)\n\t\t\t: normExp((x - min) / (max - min) || 0, e));\n\t\n\t/**\n\t * @param {any} x\n\t * @param {number} min\n\t * @param {number} max\n\t */\n\tconst denormalize = (x, min, max, e = 0) => (\n\t\tmin === 0 && max === 1\n\t\t\t? denormExp(x, e)\n\t\t\t: denormExp(x, e) * (max - min) + min\n\t);\n\t\n\t/**\n\t * @param {number} x\n\t * @param {number} min\n\t * @param {number} max\n\t */\n\tconst inRange = (x, min, max) => (x >= min && x <= max);\n\t\n\t/**\n\t * @implements {IWamParameterInfo}\n\t */\n\tclass WamParameterInfo {\n\t\t/**\n\t\t * @param {string} id\n\t\t * @param {WamParameterConfiguration} [config]\n\t\t */\n\t\tconstructor(id, config = {}) {\n\t\t\tlet {\n\t\t\t\ttype, label, defaultValue, minValue, maxValue, discreteStep, exponent, choices, units,\n\t\t\t} = config;\n\t\t\tif (type === undefined) type = 'float';\n\t\t\tif (label === undefined) label = '';\n\t\t\tif (defaultValue === undefined) defaultValue = 0;\n\t\t\tif (choices === undefined) choices = [];\n\t\t\tif (type === 'boolean' || type === 'choice') {\n\t\t\t\tdiscreteStep = 1;\n\t\t\t\tminValue = 0;\n\t\t\t\tif (choices.length) maxValue = choices.length - 1;\n\t\t\t\telse maxValue = 1;\n\t\t\t} else {\n\t\t\t\tif (minValue === undefined) minValue = 0;\n\t\t\t\tif (maxValue === undefined) maxValue = 1;\n\t\t\t\tif (discreteStep === undefined) discreteStep = 0;\n\t\t\t\tif (exponent === undefined) exponent = 0;\n\t\t\t\tif (units === undefined) units = '';\n\t\t\t}\n\t\n\t\t\tconst errBase = `Param config error | ${id}: `;\n\t\t\tif (minValue >= maxValue) throw Error(errBase.concat('minValue must be less than maxValue'));\n\t\t\tif (!inRange(defaultValue, minValue, maxValue)) throw Error(errBase.concat('defaultValue out of range'));\n\t\t\tif (discreteStep % 1 || discreteStep < 0) {\n\t\t\t\tthrow Error(errBase.concat('discreteStep must be a non-negative integer'));\n\t\t\t} else if (discreteStep > 0 && (minValue % 1 || maxValue % 1 || defaultValue % 1)) {\n\t\t\t\tthrow Error(errBase.concat('non-zero discreteStep requires integer minValue, maxValue, and defaultValue'));\n\t\t\t}\n\t\t\tif (type === 'choice' && !choices.length) {\n\t\t\t\tthrow Error(errBase.concat('choice type parameter requires list of strings in choices'));\n\t\t\t}\n\t\n\t\t\t/**\n\t\t\t * The parameter's unique identifier.\n\t\t\t * @readonly @type {string}\n\t\t\t */\n\t\t\tthis.id = id;\n\t\n\t\t\t/**\n\t\t\t * The parameter's human-readable name.\n\t\t\t * @readonly @type {string}\n\t\t\t */\n\t\t\tthis.label = label;\n\t\n\t\t\t/**\n\t\t\t * The parameter's data type.\n\t\t\t * @readonly @type {WamParameterType}\n\t\t\t */\n\t\t\tthis.type = type;\n\t\n\t\t\t/**\n\t\t\t * The parameter's default value. Must be\n\t\t\t * within range `[minValue, maxValue]`.\n\t\t\t * @readonly @type {number}\n\t\t\t */\n\t\t\tthis.defaultValue = defaultValue;\n\t\n\t\t\t/**\n\t\t\t * The minimum valid value of the parameter's range.\n\t\t\t * @readonly @type {number}\n\t\t\t */\n\t\t\tthis.minValue = minValue;\n\t\n\t\t\t/**\n\t\t\t * The maximum valid value of the parameter's range.\n\t\t\t * @readonly @type {number}\n\t\t\t */\n\t\t\tthis.maxValue = maxValue;\n\t\n\t\t\t/**\n\t\t\t * The distance between adjacent valid integer\n\t\t\t * values, if applicable.\n\t\t\t * @readonly @type {number}\n\t\t\t */\n\t\t\tthis.discreteStep = discreteStep;\n\t\n\t\t\t/**\n\t\t\t * The nonlinear (exponential) skew of the parameter's\n\t\t\t * range, if applicable.\n\t\t\t *  @readonly @type {number}\n\t\t\t */\n\t\t\tthis.exponent = exponent;\n\t\n\t\t\t/**\n\t\t\t * A list of human-readable choices corresponding to each\n\t\t\t * valid integer value in the parameter's range, if applicable.\n\t\t\t * @readonly @type {string[]}\n\t\t\t */\n\t\t\tthis.choices = choices;\n\t\n\t\t\t/**\n\t\t\t * A human-readable string representing the units of the\n\t\t\t * parameter's range, if applicable.\n\t\t\t * @readonly @type {string}\n\t\t\t */\n\t\t\tthis.units = units;\n\t\t}\n\t\n\t\t/**\n\t\t * Convert a value from the parameter's denormalized range\n\t\t * `[minValue, maxValue]` to normalized range `[0, 1]`.\n\t\t * @param {number} value\n\t\t */\n\t\tnormalize(value) {\n\t\t\treturn normalize(value, this.minValue, this.maxValue, this.exponent);\n\t\t}\n\t\n\t\t/**\n\t\t * Convert a value from normalized range `[0, 1]` to the\n\t\t * parameter's denormalized range `[minValue, maxValue]`.\n\t\t * @param {number} valueNorm\n\t\t */\n\t\tdenormalize(valueNorm) {\n\t\t\treturn denormalize(valueNorm, this.minValue, this.maxValue, this.exponent);\n\t\t}\n\t\n\t\t/**\n\t\t * Get a human-readable string representing the given value,\n\t\t * including units if applicable.\n\t\t * @param {number} value\n\t\t */\n\t\tvalueString(value) {\n\t\t\tif (this.choices) return this.choices[value];\n\t\t\tif (this.units !== '') return `${value} ${this.units}`;\n\t\t\treturn `${value}`;\n\t\t}\n\t}\n\n\tif (audioWorkletGlobalScope.AudioWorkletProcessor) {\n\t\t/** @type {WamSDKBaseModuleScope} */\n\t\tconst ModuleScope = audioWorkletGlobalScope.webAudioModules.getModuleScope(moduleId);\n\t\n\t\tif (!ModuleScope.WamParameterInfo) ModuleScope.WamParameterInfo = WamParameterInfo;\n\t}\n\n\treturn WamParameterInfo;\n};\n\nexport default getWamParameterInfo;\n", "/** @typedef {import('@webaudiomodules/api').WamParameterInfo} WamParameterInfo */\n/** @typedef {import('@webaudiomodules/api').AudioWorkletGlobalScope} AudioWorkletGlobalScope */\n/** @typedef {import('./types').WamParameterInterpolator} IWamParameterInterpolator */\n/** @typedef {typeof import('./types').WamParameterInterpolator} WamParameterInterpolatorConstructor */\n/** @typedef {import('./types').WamSDKBaseModuleScope} WamSDKBaseModuleScope */\n\n/**\n * @param {string} [moduleId]\n * @returns {WamParameterInterpolatorConstructor}\n */\nconst getWamParameterInterpolator = (moduleId) => {\n\t/** @type {AudioWorkletGlobalScope} */\n\t// @ts-ignore\n\tconst audioWorkletGlobalScope = globalThis;\n\n\tconst samplesPerQuantum = 128;\n\tconst nullTableKey = '0_0';\n\t\n\t/**\n\t * Provides per-sample value updates for WamParameters\n\t * with interpolation when applicable. Only one instance\n\t * should be created per WamParameter.\n\t * @implements {IWamParameterInterpolator}\n\t */\n\tclass WamParameterInterpolator {\n\t\t/**\n\t\t * Lookup tables to avoid recomputing interpolation curves. Keyed\n\t\t * by `'<samplesPerInterpolation>_<skew>'`. Not used for\n\t\t * discrete parameters.\n\t\t * @static @type {Record<string, Float32Array>}\n\t\t */\n\t\tstatic _tables;\n\t\n\t\t/**\n\t\t * List of parameter ids currently using the lookup table associated\n\t\t * with the key. Keyed by `'<samplesPerInterpolation>_<skew>'`.\n\t\t * For purging unused lookup tables. Not used for discrete parameters.\n\t\t * @static @type {Record<string, string[]>}\n\t\t */\n\t\tstatic _tableReferences;\n\t\n\t\t/**\n\t\t * @param {WamParameterInfo} info\n\t\t * @param {number} samplesPerInterpolation\n\t\t * @param {number=} skew\n\t\t */\n\t\tconstructor(info, samplesPerInterpolation, skew = 0) {\n\t\t\tif (!WamParameterInterpolator._tables) {\n\t\t\t\tWamParameterInterpolator._tables = { nullTableKey: new Float32Array(0) };\n\t\t\t\tWamParameterInterpolator._tableReferences = { nullTableKey: [] };\n\t\t\t}\n\t\n\t\t\t/**\n\t\t\t * Info object for corresponding WamParameter.\n\t\t\t * @readonly @type {WamParameterInfo}\n\t\t\t */\n\t\t\tthis.info = info;\n\t\n\t\t\t/**\n\t\t\t * Buffer storing per-sample values.\n\t\t\t * @readonly @type {Float32Array}\n\t\t\t */\n\t\t\tthis.values = new Float32Array(samplesPerQuantum);\n\t\n\t\t\t/**\n\t\t\t * Composed by concatenating `'<samplesPerInterpolation>_<skew>'`.\n\t\t\t * @private @type {string}\n\t\t\t */\n\t\t\tthis._tableKey = nullTableKey;\n\t\n\t\t\t/**\n\t\t\t * The (static) lookup table used to avoid recomputing ramps.\n\t\t\t * @private @type {Float32Array}\n\t\t\t */\n\t\t\tthis._table = WamParameterInterpolator._tables[this._tableKey];\n\t\n\t\t\t/**\n\t\t\t * Determines if interpolation will be linear / nonlinear.\n\t\t\t * Note that this is distinct from the corresponding\n\t\t\t * parameter's `exponent` value.\n\t\t\t * @private @type {number}\n\t\t\t */\n\t\t\tthis._skew = 2; // intentionally initialized out of range, see setSkew\n\t\n\t\t\tconst { discreteStep } = info;\n\t\n\t\t\t/**\n\t\t\t * Whether or not to perform interpolation\n\t\t\t * (false for integer parameters, true otherwise).\n\t\t\t * @readonly @private @type {boolean}\n\t\t\t */\n\t\t\tthis._discrete = !!discreteStep;\n\t\n\t\t\t/**\n\t\t\t * The interpolation period in samples.\n\t\t\t * @readonly @private @type {number}\n\t\t\t */\n\t\t\tthis._N = this._discrete ? 0 : samplesPerInterpolation;\n\t\n\t\t\t/**\n\t\t\t * The current interpolation index.\n\t\t\t * @private @type {number}\n\t\t\t */\n\t\t\tthis._n = 0;\n\t\n\t\t\t/**\n\t\t\t * The parameter value when interpolation starts.\n\t\t\t * @private @type {number}\n\t\t\t*/\n\t\t\tthis._startValue = info.defaultValue;\n\t\n\t\t\t/**\n\t\t\t * The parameter value when interpolation ends.\n\t\t\t * @private @type {number}\n\t\t\t */\n\t\t\tthis._endValue = info.defaultValue;\n\t\n\t\t\t/**\n\t\t\t * The most recently computed parameter value.\n\t\t\t * @private @type {number}\n\t\t\t */\n\t\t\tthis._currentValue = info.defaultValue;\n\t\n\t\t\t/**\n\t\t\t * The difference between `startValue` and `endValue`.\n\t\t\t * @private @type {number}\n\t\t\t */\n\t\t\tthis._deltaValue = 0;\n\t\n\t\t\t/**\n\t\t\t * Allows consistent output with respect to skew setting\n\t\t\t * whether increasing or decreasing during interpolation.\n\t\t\t * @private @type {boolean}\n\t\t\t */\n\t\t\tthis._inverted = false;\n\t\n\t\t\t/**\n\t\t\t * Whether the most recently requested interpolation has completed.\n\t\t\t * @private @type {boolean}\n\t\t\t */\n\t\t\tthis._changed = true;\n\t\n\t\t\t/**\n\t\t\t * How many samples have been uniformly filled following\n\t\t\t * completion of most recently requested interpolation.\n\t\t\t * @private @type {number}\n\t\t\t */\n\t\t\tthis._filled = 0;\n\t\n\t\t\tif (!this._discrete) this.setSkew(skew);\n\t\t\telse this._skew = 0;\n\t\t\tthis.setStartValue(this._startValue);\n\t\t}\n\t\n\t\t/**\n\t\t * Utility for managing lifecycles of lookup tables.\n\t\t * @private\n\t\t * @param {string} oldKey\n\t\t */\n\t\t_removeTableReference(oldKey) {\n\t\t\tif (oldKey === nullTableKey) return;\n\t\t\tconst { id } = this.info;\n\t\t\t/** @type {string[] | undefined} */\n\t\t\tconst references = WamParameterInterpolator._tableReferences[oldKey];\n\t\t\tif (references) {\n\t\t\t\tconst index = references.indexOf(id);\n\t\t\t\tif (index !== -1) references.splice(index, 1);\n\t\t\t\t// clean up?\n\t\t\t\tif (references.length === 0) {\n\t\t\t\t\tdelete WamParameterInterpolator._tables[oldKey];\n\t\t\t\t\tdelete WamParameterInterpolator._tableReferences[oldKey];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t/**\n\t\t * Update interpolation curve based on skew factor in range `[-1, 1]`.\n\t\t * Setting to `0` results in linear interpolation. Positive values\n\t\t * result in convex exponential curves while negative vales result\n\t\t * in concave exponential curves.\n\t\t * @param {number} skew\n\t\t */\n\t\tsetSkew(skew) {\n\t\t\tif (this._skew === skew || this._discrete) return;\n\t\t\tif (skew < -1 || skew > 1) throw Error('skew must be in range [-1.0, 1.0]');\n\t\n\t\t\tconst newKey = [this._N, skew].join('_');\n\t\t\tconst oldKey = this._tableKey;\n\t\t\tconst { id } = this.info;\n\t\t\t// just in case...\n\t\t\tif (newKey === oldKey) return;\n\t\n\t\t\tif (WamParameterInterpolator._tables[newKey]) { // lookup table already exists\n\t\t\t\t// add new reference\n\t\t\t\t/** @type {string[] | undefined} */\n\t\t\t\tconst references = WamParameterInterpolator._tableReferences[newKey];\n\t\t\t\tif (references) references.push(id);\n\t\t\t\telse WamParameterInterpolator._tableReferences[newKey] = [id];\n\t\t\t} else { // compute new lookup table\n\t\t\t\tlet e = Math.abs(skew);\n\t\t\t\t/* eslint-disable-next-line */\n\t\t\t\te = Math.pow(3.0 - e, e * (e + 2.0));\n\t\t\t\tconst linear = e === 1.0;\n\t\t\t\tconst N = this._N;\n\t\t\t\tconst table = new Float32Array(N + 1);\n\t\t\t\tif (linear) for (let n = 0; n <= N; ++n) table[n] = (n / N);\n\t\t\t\telse for (let n = 0; n <= N; ++n) table[n] = (n / N) ** e;\n\t\n\t\t\t\tWamParameterInterpolator._tables[newKey] = table;\n\t\t\t\tWamParameterInterpolator._tableReferences[newKey] = [id];\n\t\t\t}\n\t\t\t// remove old reference\n\t\t\tthis._removeTableReference(oldKey);\n\t\t\tthis._skew = skew;\n\t\t\tthis._tableKey = newKey;\n\t\t\tthis._table = WamParameterInterpolator._tables[this._tableKey];\n\t\t}\n\t\n\t\t/**\n\t\t * Reset the interpolator to specified value, setting all per-sample\n\t\t * values immediately if `fill` is `true`. Assumes `value` is within\n\t\t * parameter's valid range `[minValue, maxValue]`;\n\t\t * @param {number} value\n\t\t * @param {boolean} fill\n\t\t */\n\t\tsetStartValue(value, fill = true) {\n\t\t\tthis._n = this._N;\n\t\t\tthis._startValue = value;\n\t\t\tthis._endValue = value;\n\t\t\tthis._currentValue = value;\n\t\t\tthis._deltaValue = 0;\n\t\t\tthis._inverted = false;\n\t\t\tif (fill) {\n\t\t\t\tthis.values.fill(value);\n\t\t\t\tthis._changed = true;\n\t\t\t\tthis._filled = this.values.length;\n\t\t\t} else {\n\t\t\t\tthis._changed = false;\n\t\t\t\tthis._filled = 0;\n\t\t\t}\n\t\t}\n\t\n\t\t/**\n\t\t * Prepare to compute per-sample values interpolating to `value` on\n\t\t * next `process` call. Assumes `value` is within parameter's valid\n\t\t * range `[minValue, maxValue]`;\n\t\t * @param {number} value\n\t\t */\n\t\tsetEndValue(value) {\n\t\t\tif (value === this._endValue) return;\n\t\t\tthis._n = 0;\n\t\t\tthis._startValue = this._currentValue;\n\t\t\tthis._endValue = value;\n\t\t\tthis._deltaValue = this._endValue - this._startValue;\n\t\t\tthis._inverted = (this._deltaValue > 0 && this._skew >= 0)\n\t\t\t|| (this._deltaValue <= 0 && this._skew < 0);\n\t\t\tthis._changed = false;\n\t\t\tthis._filled = 0;\n\t\t}\n\t\n\t\t/**\n\t\t * Compute per-sample value updates in the specified range `[startSample, endSample)`,\n\t\t * interpolating if applicable. Results are stored in `values`. Assumes this will be\n\t\t * called once per parameter per processing slice in `WamProcessor.process`.\n\t\t * @param {number} startSample\n\t\t * @param {number} endSample\n\t\t */\n\t\tprocess(startSample, endSample) {\n\t\t\tif (this.done) return;\n\t\t\tconst length = endSample - startSample;\n\t\t\tlet fill = 0;\n\t\t\tconst change = this._N - this._n;\n\t\t\tif (this._discrete || !change) fill = length;\n\t\t\telse {\n\t\t\t\tif (change < length) {\n\t\t\t\t\tfill = Math.min(length - change, samplesPerQuantum);\n\t\t\t\t\tendSample -= fill;\n\t\t\t\t}\n\t\t\t\tif (endSample > startSample) { // interpolate\n\t\t\t\t\tif (this._inverted) {\n\t\t\t\t\t\tfor (let i = startSample; i < endSample; ++i) {\n\t\t\t\t\t\t\tconst tableValue = 1.0 - this._table[this._N - ++this._n];\n\t\t\t\t\t\t\tthis.values[i] = this._startValue + tableValue * this._deltaValue;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (let i = startSample; i < endSample; ++i) {\n\t\t\t\t\t\t\tconst tableValue = this._table[++this._n];\n\t\t\t\t\t\t\tthis.values[i] = this._startValue + tableValue * this._deltaValue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (fill > 0) {\n\t\t\t\t\tstartSample = endSample;\n\t\t\t\t\tendSample += fill;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (fill > 0) {\n\t\t\t\t// fill any remaining slots\n\t\t\t\tthis.values.fill(this._endValue, startSample, endSample);\n\t\t\t\tthis._filled += fill;\n\t\t\t}\n\t\t\tthis._currentValue = this.values[endSample - 1];\n\t\t\tif (this._n === this._N) {\n\t\t\t\tif (!this._changed) this._changed = true;\n\t\t\t\telse if (this._filled >= this.values.length) {\n\t\t\t\t\tthis.setStartValue(this._endValue, false);\n\t\t\t\t\tthis._changed = true;\n\t\t\t\t\tthis._filled = this.values.length;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t/**\n\t\t * Whether or not further processing is required before\n\t\t * accessing per-sample values.\n\t\t * @returns {boolean}\n\t\t */\n\t\tget done() {\n\t\t\treturn this._changed && this._filled === this.values.length;\n\t\t}\n\t\n\t\t/**\n\t\t * Whether or not interpolation is complete and internal state\n\t\t * is equal to `value`.\n\t\t * @param {number} value\n\t\t * @returns {boolean}\n\t\t */\n\t\tis(value) {\n\t\t\treturn this._endValue === value && this.done;\n\t\t}\n\t\n\t\t/**\n\t\t * Call this when no longer using the instance in order\n\t\t * to allow deletion of unused static lookup tables.\n\t\t */\n\t\tdestroy() {\n\t\t\t// clean out reference associated with this instance\n\t\t\tthis._removeTableReference(this._tableKey);\n\t\t}\n\t}\n\n\tif (audioWorkletGlobalScope.AudioWorkletProcessor) {\n\t\t/** @type {WamSDKBaseModuleScope} */\n\t\tconst ModuleScope = audioWorkletGlobalScope.webAudioModules.getModuleScope(moduleId);\n\t\n\t\tif (!ModuleScope.WamParameterInterpolator) ModuleScope.WamParameterInterpolator = WamParameterInterpolator;\n\t}\n\n\treturn WamParameterInterpolator;\n};\n\nexport default getWamParameterInterpolator;\n", "/** @typedef {import('@webaudiomodules/api').WamProcessor} IWamProcessor */\n/** @typedef {typeof import('@webaudiomodules/api').WamProcessor} WamProcessorConstructor */\n/** @typedef {import('@webaudiomodules/api').WamParameter} WamParameter */\n/** @typedef {import('@webaudiomodules/api').WamParameterInfoMap} WamParameterInfoMap */\n/** @typedef {import('@webaudiomodules/api').WamParameterDataMap} WamParameterDataMap */\n/** @typedef {import('@webaudiomodules/api').WamParameterData} WamParameterData */\n/** @typedef {import('@webaudiomodules/api').WamParameterMap} WamParameterMap */\n/** @typedef {import('@webaudiomodules/api').WamEvent} WamEvent */\n/** @typedef {import('@webaudiomodules/api').WamTransportData} WamTransportData */\n/** @typedef {import('@webaudiomodules/api').WamMidiData} WamMidiData */\n/** @typedef {import('@webaudiomodules/api').WamBinaryData} WamBinaryData */\n/** @typedef {import('@webaudiomodules/api').AudioWorkletGlobalScope} AudioWorkletGlobalScope */\n/** @typedef {import('./types').PendingWamEvent} PendingWamEvent */\n/** @typedef {import('./types').ProcessingSlice} ProcessingSlice */\n/** @typedef {import('./types').WamParameterInterpolatorMap} WamParameterInterpolatorMap */\n/** @typedef {import('./types').WamEventRingBuffer} WamEventRingBuffer */\n/** @typedef {import('./types').WamSDKBaseModuleScope} WamSDKBaseModuleScope */\n\n/**\n * @param {string} moduleId\n * @returns {WamProcessorConstructor}\n */\nconst getWamProcessor = (moduleId) => {\n\t/** @type {AudioWorkletGlobalScope} */\n\t// @ts-ignore\n\tconst audioWorkletGlobalScope = globalThis;\n\tconst {\n\t\tAudioWorkletProcessor,\n\t\twebAudioModules,\n\t} = audioWorkletGlobalScope;\n\n\t/** @type {WamSDKBaseModuleScope} */\n\tconst ModuleScope = audioWorkletGlobalScope.webAudioModules.getModuleScope(moduleId);\n\tconst {\n\t\tRingBuffer,\n\t\tWamEventRingBuffer,\n\t\tWamParameter,\n\t\tWamParameterInterpolator\n\t} = ModuleScope;\n\n\t/**\n\t * @implements {IWamProcessor}\n\t */\n\tclass WamProcessor extends AudioWorkletProcessor {\n\t\t/**\n\t\t * @param {AudioWorkletNodeOptions} options\n\t\t */\n\t\tconstructor(options) {\n\t\t\tsuper();\n\t\t\tconst {\n\t\t\t\tgroupId,\n\t\t\t\tmoduleId,\n\t\t\t\tinstanceId,\n\t\t\t\tuseSab,\n\t\t\t} = options.processorOptions;\n\n\t\t\tif (!moduleId) throw Error('must provide moduleId argument in processorOptions!');\n\t\t\tif (!instanceId) throw Error('must provide instanceId argument in processorOptions!');\n\n\t\t\t/** @type {string} */\n\t\t\tthis.groupId = groupId;\n\t\t\t/** @type {string} */\n\t\t\tthis.moduleId = moduleId;\n\t\t\t/** @type {string} */\n\t\t\tthis.instanceId = instanceId;\n\t\t\t/** @type {number} */\n\t\t\tthis._samplesPerQuantum = 128;\n\t\t\t/** @type {number} */\n\t\t\tthis._compensationDelay = 0;\n\t\t\t/** @type {WamParameterInfoMap} */\n\t\t\tthis._parameterInfo = {};\n\t\t\t/** @type {WamParameterMap} */\n\t\t\tthis._parameterState = {};\n\t\t\t/** @type {WamParameterInterpolatorMap} */\n\t\t\tthis._parameterInterpolators = {};\n\t\t\t/** @type {PendingWamEvent[]} */\n\t\t\tthis._eventQueue = [];\n\t\t\t/** @type {Record<number, (...args: any[]) => any>} */\n\t\t\tthis._pendingResponses = {};\n\t\t\t/** @type {boolean} */\n\t\t\tthis._useSab = !!useSab && !!globalThis.SharedArrayBuffer;\n\t\t\t/** @type {boolean} */\n\t\t\tthis._eventSabReady = false;\n\t\t\t/** @type {SharedArrayBuffer} */\n\t\t\tthis._audioToMainEventSab = null;\n\t\t\t/** @type {SharedArrayBuffer} */\n\t\t\tthis._mainToAudioEventSab = null;\n\t\t\t/** @type {WamEventRingBuffer} */\n\t\t\tthis._eventWriter = null;\n\t\t\t/** @type {WamEventRingBuffer} */\n\t\t\tthis._eventReader = null;\n\t\t\t/** @type {boolean} */\n\t\t\tthis._initialized = false;\n\t\t\t/** @type {boolean} */\n\t\t\tthis._destroyed = false;\n\n\t\t\twebAudioModules.addWam(this);\n\n\t\t\tthis.port.onmessage = this._onMessage.bind(this);\n\n\t\t\tif (this._useSab) this._configureSab();\n\t\t}\n\n\t\t/**\n\t\t * Compensation delay hint in seconds.\n\t\t * @returns {number}\n\t\t */\n\t\tgetCompensationDelay() { return this._compensationDelay; }\n\n\t\t/**\n\t\t * Schedule a WamEvent.\n\t\t * Listeners will be triggered when the event is processed.\n\t\t * @param {WamEvent[]} events\n\t\t */\n\t\tscheduleEvents(...events) {\n\t\t\tlet i = 0;\n\t\t\twhile (i < events.length) {\n\t\t\t\t// no need for ids if scheduled from audio thread\n\t\t\t\tthis._eventQueue.push({ id: 0, event: events[i] });\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Schedule events for all the downstream WAMs\n\t\t * @param {WamEvent[]} events\n\t\t */\n\t\temitEvents(...events) {\n\t\t\twebAudioModules.emitEvents(this, ...events);\n\t\t}\n\n\t\t/**\n\t\t * Clear all pending WamEvents.\n\t\t */\n\t\tclearEvents() {\n\t\t\tthis._eventQueue = [];\n\t\t}\n\n\t\t/**\n\t\t * Process a block of samples. Note that `parameters` argument is ignored.\n\t\t * @param {Float32Array[][]} inputs\n\t\t * @param {Float32Array[][]} outputs\n\t\t * @param {{[x: string]: Float32Array}} parameters\n\t\t */\n\t\tprocess(inputs, outputs, parameters) {\n\t\t\tif (!this._initialized) return true;\n\t\t\tif (this._destroyed) return false;\n\t\t\tif (this._eventSabReady) this.scheduleEvents(...this._eventReader.read());\n\n\t\t\tconst processingSlices = this._getProcessingSlices();\n\t\t\tlet i = 0;\n\t\t\twhile (i < processingSlices.length) {\n\t\t\t\tconst { range, events } = processingSlices[i];\n\t\t\t\tconst [startSample, endSample] = range;\n\t\t\t\t// pause to process events at proper sample\n\t\t\t\tlet j = 0;\n\t\t\t\twhile (j < events.length) {\n\t\t\t\t\tthis._processEvent(events[j]);\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\t// perform parameter interpolation\n\t\t\t\tthis._interpolateParameterValues(startSample, endSample);\n\t\t\t\t// continue processing\n\t\t\t\tthis._process(startSample, endSample, inputs, outputs, parameters);\n\t\t\t\ti++;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\t/**\n\t\t * Stop processing and remove the node from the WAM event graph.\n\t\t */\n\t\tdestroy() {\n\t\t\tthis._destroyed = true;\n\t\t\tthis.port.close();\n\t\t\twebAudioModules.removeWam(this);\n\t\t}\n\n\t\t/**\n\t\t * Override to generate map of WamParameterInfo objects.\n\t\t * @returns {WamParameterInfoMap}\n\t\t */\n\t\t_generateWamParameterInfo() { return {}; }\n\n\t\t/**\n\t\t * Post-constructor initialization method.\n\t\t */\n\t\t_initialize() {\n\t\t\tthis._parameterState = {};\n\t\t\tthis._parameterInterpolators = {};\n\t\t\tthis._parameterInfo = this._generateWamParameterInfo();\n\t\t\tObject.keys(this._parameterInfo).forEach((parameterId) => {\n\t\t\t\tconst info = this._parameterInfo[parameterId];\n\t\t\t\tthis._parameterState[parameterId] = new WamParameter(this._parameterInfo[parameterId]);\n\t\t\t\tthis._parameterInterpolators[parameterId] = new WamParameterInterpolator(info, 256);\n\t\t\t});\n\t\t}\n\n\t\t/**\n\t\t * Communicate with WamNode to configure SharedArrayBuffers.\n\t\t */\n\t\t_configureSab() {\n\t\t\tconst eventCapacity = 2 ** 10;\n\t\t\tconst parameterIds = Object.keys(this._parameterInfo);\n\t\t\tif (this._eventSabReady) {\n\t\t\t\t// if parameter set changes after initialization\n\t\t\t\tthis._eventWriter.setParameterIds(parameterIds);\n\t\t\t\tthis._eventReader.setParameterIds(parameterIds);\n\t\t\t}\n\t\t\tthis.port.postMessage({ eventSab: { eventCapacity, parameterIds } });\n\t\t}\n\n\t\t/**\n\t\t * Messages from main thread appear here.\n\t\t * @param {MessageEvent} message\n\t\t */\n\t\tasync _onMessage(message) {\n\t\t\tif (message.data.request) {\n\t\t\t\tconst {\n\t\t\t\t\tid, request, content,\n\t\t\t\t} = message.data;\n\t\t\t\tconst response = { id, response: request };\n\t\t\t\tconst requestComponents = request.split('/');\n\t\t\t\tconst verb = requestComponents[0];\n\t\t\t\tconst noun = requestComponents[1];\n\t\t\t\tresponse.content = 'error';\n\t\t\t\tif (verb === 'get') {\n\t\t\t\t\tif (noun === 'parameterInfo') {\n\t\t\t\t\t\tlet { parameterIds } = content;\n\t\t\t\t\t\tif (!parameterIds.length) parameterIds = Object.keys(this._parameterInfo);\n\t\t\t\t\t\tconst parameterInfo = {};\n\t\t\t\t\t\tlet i = 0;\n\t\t\t\t\t\twhile (i < parameterIds.length) {\n\t\t\t\t\t\t\tconst parameterId = parameterIds[i];\n\t\t\t\t\t\t\tparameterInfo[parameterId] = this._parameterInfo[parameterId];\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresponse.content = parameterInfo;\n\t\t\t\t\t} else if (noun === 'parameterValues') {\n\t\t\t\t\t\t/*eslint-disable-next-line prefer-const */\n\t\t\t\t\t\tlet { normalized, parameterIds } = content;\n\t\t\t\t\t\tresponse.content = this._getParameterValues(normalized, parameterIds);\n\t\t\t\t\t} else if (noun === 'state') {\n\t\t\t\t\t\tresponse.content = this._getState();\n\t\t\t\t\t\t// ...additional state?\n\t\t\t\t\t} else if (noun === 'compensationDelay') {\n\t\t\t\t\t\tresponse.content = this.getCompensationDelay();\n\t\t\t\t\t}\n\t\t\t\t} else if (verb === 'set') {\n\t\t\t\t\tif (noun === 'parameterValues') {\n\t\t\t\t\t\tconst { parameterValues } = content;\n\t\t\t\t\t\tthis._setParameterValues(parameterValues, true);\n\t\t\t\t\t\tdelete response.content;\n\t\t\t\t\t} else if (noun === 'state') {\n\t\t\t\t\t\tconst { state } = content;\n\t\t\t\t\t\tthis._setState(state);\n\t\t\t\t\t\t// ...additional state?\n\t\t\t\t\t\tdelete response.content;\n\t\t\t\t\t}\n\t\t\t\t} else if (verb === 'add') {\n\t\t\t\t\tif (noun === 'event') {\n\t\t\t\t\t\tconst { event } = content;\n\t\t\t\t\t\tthis._eventQueue.push({ id, event });\n\t\t\t\t\t\treturn; // defer postMessage until event is processed\n\t\t\t\t\t}\n\t\t\t\t} else if (verb === 'remove') {\n\t\t\t\t\tif (noun === 'events') {\n\t\t\t\t\t\tconst ids = this._eventQueue.map((queued) => queued.id);\n\t\t\t\t\t\tthis.clearEvents();\n\t\t\t\t\t\tresponse.content = ids;\n\t\t\t\t\t}\n\t\t\t\t} else if (verb === 'connect') {\n\t\t\t\t\tif (noun === 'events') {\n\t\t\t\t\t\tconst { wamInstanceId, output } = content;\n\t\t\t\t\t\tthis._connectEvents(wamInstanceId, output);\n\t\t\t\t\t\tdelete response.content;\n\t\t\t\t\t}\n\t\t\t\t} else if (verb === 'disconnect') {\n\t\t\t\t\tif (noun === 'events') {\n\t\t\t\t\t\tconst { wamInstanceId, output } = content;\n\t\t\t\t\t\tthis._disconnectEvents(wamInstanceId, output);\n\t\t\t\t\t\tdelete response.content;\n\t\t\t\t\t}\n\t\t\t\t} else if (verb === 'initialize') {\n\t\t\t\t\tif (noun === 'processor') {\n\t\t\t\t\t\tthis._initialize();\n\t\t\t\t\t\tthis._initialized = true;\n\t\t\t\t\t\tdelete response.content;\n\t\t\t\t\t}\n\t\t\t\t\telse if (noun === 'eventSab') {\n\t\t\t\t\t\tconst { mainToAudioEventSab, audioToMainEventSab } = content;\n\n\t\t\t\t\t\t/** @private @type {SharedArrayBuffer} */\n\t\t\t\t\t\tthis._audioToMainEventSab = audioToMainEventSab;\n\n\t\t\t\t\t\t/** @private @type {SharedArrayBuffer} */\n\t\t\t\t\t\tthis._mainToAudioEventSab = mainToAudioEventSab;\n\n\t\t\t\t\t\tconst parameterIds = Object.keys(this._parameterInfo);\n\t\t\t\t\t\t/** @private @type {WamEventRingBuffer} */\n\t\t\t\t\t\tthis._eventWriter = new WamEventRingBuffer(RingBuffer, this._audioToMainEventSab,\n\t\t\t\t\t\t\tparameterIds);\n\t\t\t\t\t\t/** @private @type {WamEventRingBuffer} */\n\t\t\t\t\t\tthis._eventReader = new WamEventRingBuffer(RingBuffer, this._mainToAudioEventSab,\n\t\t\t\t\t\t\tparameterIds);\n\n\t\t\t\t\t\tthis._eventSabReady = true;\n\t\t\t\t\t\tdelete response.content;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.port.postMessage(response);\n\t\t\t} else if (message.data.destroy) {\n\t\t\t\tthis.destroy();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @param {WamTransportData} transportData\n\t\t */\n\t\t_onTransport(transportData) {\n\t\t\t// Override for custom transport handling\n\t\t\t// eslint-disable-next-line no-console\n\t\t\tconsole.error('_onTransport not implemented!');\n\t\t}\n\n\t\t/**\n\t\t * @param {WamMidiData} midiData\n\t\t */\n\t\t_onMidi(midiData) {\n\t\t\t// Override for custom midi handling\n\t\t\t// eslint-disable-next-line no-console\n\t\t\tconsole.error('_onMidi not implemented!');\n\t\t}\n\n\t\t/**\n\t\t * @param {WamBinaryData} sysexData\n\t\t */\n\t\t_onSysex(sysexData) {\n\t\t\t// Override for custom sysex handling\n\t\t\t// eslint-disable-next-line no-console\n\t\t\tconsole.error('_onMidi not implemented!');\n\t\t}\n\n\t\t/**\n\t\t * @param {WamMidiData} mpeData\n\t\t */\n\t\t_onMpe(mpeData) {\n\t\t\t// Override for custom mpe handling\n\t\t\t// eslint-disable-next-line no-console\n\t\t\tconsole.error('_onMpe not implemented!');\n\t\t}\n\n\t\t/**\n\t\t * @param {WamBinaryData} oscData\n\t\t */\n\t\t_onOsc(oscData) {\n\t\t\t// Override for custom osc handling\n\t\t\t// eslint-disable-next-line no-console\n\t\t\tconsole.error('_onOsc not implemented!');\n\t\t}\n\n\t\t/**\n\t\t * @param {any} state\n\t\t */\n\t\t_setState(state) {\n\t\t\tif (state.parameterValues) this._setParameterValues(state.parameterValues, false);\n\t\t}\n\n\t\t/**\n\t\t * @returns {any}\n\t\t */\n\t\t_getState() {\n\t\t\treturn { parameterValues: this._getParameterValues(false) };\n\t\t}\n\n\t\t/**\n\t\t * @param {boolean} normalized\n\t\t * @param {string[]=} parameterIds\n\t\t * @returns {WamParameterDataMap}\n\t\t */\n\t\t_getParameterValues(normalized, parameterIds) {\n\t\t\t/** @type {WamParameterDataMap} */\n\t\t\tconst parameterValues = {};\n\t\t\tif (!parameterIds || !parameterIds.length) parameterIds = Object.keys(this._parameterState);\n\t\t\tlet i = 0;\n\t\t\twhile (i < parameterIds.length) {\n\t\t\t\tconst id = parameterIds[i];\n\t\t\t\t/** @type {WamParameter} */\n\t\t\t\tconst parameter = this._parameterState[id];\n\t\t\t\tparameterValues[id] = {\n\t\t\t\t\tid,\n\t\t\t\t\tvalue: normalized ? parameter.normalizedValue : parameter.value,\n\t\t\t\t\tnormalized,\n\t\t\t\t};\n\t\t\t\ti++;\n\t\t\t}\n\t\t\treturn parameterValues;\n\t\t}\n\n\t\t/**\n\t\t * @param {WamParameterDataMap} parameterUpdates\n\t\t * @param {boolean} interpolate\n\t\t */\n\t\t_setParameterValues(parameterUpdates, interpolate) {\n\t\t\tconst parameterIds = Object.keys(parameterUpdates);\n\t\t\tlet i = 0;\n\t\t\twhile (i < parameterIds.length) {\n\t\t\t\tthis._setParameterValue(parameterUpdates[parameterIds[i]], interpolate);\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @param {WamParameterData} parameterUpdate\n\t\t * @param {boolean} interpolate\n\t\t */\n\t\t_setParameterValue(parameterUpdate, interpolate) {\n\t\t\tconst { id, value, normalized } = parameterUpdate;\n\t\t\t/** @type {WamParameter} */\n\t\t\tconst parameter = this._parameterState[id];\n\t\t\tif (!parameter) return;\n\t\t\tif (!normalized) parameter.value = value;\n\t\t\telse parameter.normalizedValue = value;\n\t\t\tconst interpolator = this._parameterInterpolators[id];\n\t\t\tif (interpolate) interpolator.setEndValue(parameter.value);\n\t\t\telse interpolator.setStartValue(parameter.value);\n\t\t}\n\n\t\t/**\n\t\t * @param {number} startIndex\n\t\t * @param {number} endIndex\n\t\t */\n\t\t_interpolateParameterValues(startIndex, endIndex) {\n\t\t\tconst parameterIds = Object.keys(this._parameterInterpolators);\n\t\t\tlet i = 0;\n\t\t\twhile (i < parameterIds.length) {\n\t\t\t\tthis._parameterInterpolators[parameterIds[i]].process(startIndex, endIndex);\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @param {string} wamInstanceId\n\t\t * @param {number} [output]\n\t\t */\n\t\t_connectEvents(wamInstanceId, output) {\n\t\t\twebAudioModules.connectEvents(this.groupId, this.instanceId, wamInstanceId, output);\n\t\t}\n\n\t\t/**\n\t\t * @param {string} [wamInstanceId]\n\t\t * @param {number} [output]\n\t\t */\n\t\t_disconnectEvents(wamInstanceId, output) {\n\t\t\tif (typeof wamInstanceId === 'undefined') {\n\t\t\t\twebAudioModules.disconnectEvents(this.groupId, this.instanceId);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\twebAudioModules.disconnectEvents(this.groupId, this.instanceId, wamInstanceId, output);\n\t\t}\n\n\t\t/**\n\t\t * Example implementation of custom sample accurate event scheduling.\n\t\t * @returns {ProcessingSlice[]}\n\t\t * */\n\t\t_getProcessingSlices() {\n\t\t\tconst response = 'add/event';\n\t\t\t/** @ts-ignore */\n\t\t\tconst { currentTime, sampleRate } = audioWorkletGlobalScope;\n\t\t\t/** @type {{[sampleIndex: number]: WamEvent[]}} */\n\t\t\tconst eventsBySampleIndex = {};\n\t\t\t// assumes events arrive sorted by time\n\t\t\tlet i = 0;\n\t\t\twhile (i < this._eventQueue.length) {\n\t\t\t\tconst { id, event } = this._eventQueue[i];\n\t\t\t\tconst offsetSec = event.time - currentTime;\n\t\t\t\tconst sampleIndex = offsetSec > 0 ? Math.round(offsetSec * sampleRate) : 0;\n\t\t\t\tif (sampleIndex < this._samplesPerQuantum) {\n\t\t\t\t\tif (eventsBySampleIndex[sampleIndex]) eventsBySampleIndex[sampleIndex].push(event);\n\t\t\t\t\telse eventsBySampleIndex[sampleIndex] = [event];\n\t\t\t\t\t// notify main thread\n\t\t\t\t\tif (id) this.port.postMessage({ id, response });\n\t\t\t\t\telse if (this._eventSabReady) this._eventWriter.write(event);\n\t\t\t\t\telse this.port.postMessage({ event });\n\t\t\t\t\tthis._eventQueue.shift();\n\t\t\t\t\ti = -1;\n\t\t\t\t} else break;\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\t/** @type {ProcessingSlice[]} */\n\t\t\tconst processingSlices = [];\n\t\t\tconst keys = Object.keys(eventsBySampleIndex);\n\t\t\tif (keys[0] !== '0') {\n\t\t\t\tkeys.unshift('0');\n\t\t\t\teventsBySampleIndex['0'] = [];\n\t\t\t}\n\t\t\tconst lastIndex = keys.length - 1;\n\t\t\ti = 0;\n\t\t\twhile (i < keys.length) {\n\t\t\t\tconst key = keys[i];\n\t\t\t\tconst startSample = parseInt(key);\n\t\t\t\tconst endSample = (i < lastIndex) ? parseInt(keys[i + 1]) : this._samplesPerQuantum;\n\t\t\t\tprocessingSlices.push({ range: [startSample, endSample], events: eventsBySampleIndex[key] });\n\t\t\t\ti++;\n\t\t\t}\n\t\t\treturn processingSlices;\n\t\t}\n\n\t\t/** @param {WamEvent} event */\n\t\t_processEvent(event) {\n\t\t\tswitch (event.type) {\n\t\t\tcase 'wam-automation': this._setParameterValue(event.data, true); break;\n\t\t\tcase 'wam-transport': this._onTransport(event.data); break;\n\t\t\tcase 'wam-midi': this._onMidi(event.data); break;\n\t\t\tcase 'wam-sysex': this._onSysex(event.data); break;\n\t\t\tcase 'wam-mpe': this._onMpe(event.data); break;\n\t\t\tcase 'wam-osc': this._onOsc(event.data); break;\n\t\t\tdefault: break;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Override this to implement custom DSP.\n\t\t * @param {number} startSample beginning of processing slice\n\t\t * @param {number} endSample end of processing slice\n\t\t * @param {Float32Array[][]} inputs\n\t\t * @param {Float32Array[][]} outputs\n\t\t * @param {{[x: string]: Float32Array}} parameters\n\t\t */\n\t\t_process(startSample, endSample, inputs, outputs, parameters) {\n\t\t\t// Override for custom processing\n\t\t\t// eslint-disable-next-line no-console\n\t\t\tconsole.error('_process not implemented!');\n\t\t}\n\t}\n\n\tif (audioWorkletGlobalScope.AudioWorkletProcessor) {\n\t\tif (!ModuleScope.WamProcessor) ModuleScope.WamProcessor = WamProcessor;\n\t}\n\n\treturn WamProcessor;\n};\n\nexport default getWamProcessor;\n", "/** @typedef {import('@webaudiomodules/api').WamNode} IWamNode */\n/** @typedef {import('@webaudiomodules/api').WebAudioModule} WebAudioModule */\n/** @typedef {import('@webaudiomodules/api').WamParameterInfoMap} WamParameterInfoMap */\n/** @typedef {import('@webaudiomodules/api').WamParameterDataMap} WamParameterDataMap */\n/** @typedef {import('@webaudiomodules/api').WamEvent} WamEvent */\n/** @typedef {import('@webaudiomodules/api').WamEventType} WamEventType */\n/** @typedef {import('./types').WamEventRingBuffer} WamEventRingBuffer */\n\nimport addFunctionModule from './addFunctionModule.js';\nimport getRingBuffer from './RingBuffer.js';\nimport getWamArrayRingBuffer from './WamArrayRingBuffer.js';\nimport getWamEventRingBuffer from './WamEventRingBuffer.js';\nimport getWamParameter from './WamParameter.js';\nimport getWamParameterInfo from './WamParameterInfo.js';\nimport getWamParameterInterpolator from './WamParameterInterpolator.js';\nimport getWamProcessor from './WamProcessor.js';\n\nconst RingBuffer = getRingBuffer();\nconst WamEventRingBuffer = getWamEventRingBuffer();\n\n/**\n * @implements {IWamNode}\n */\nexport default class WamNode extends AudioWorkletNode {\n\t/**\n\t * Register scripts required for the processor. Must be called before constructor.\n\t * @param {BaseAudioContext} audioContext\n\t * @param {string} moduleId\n\t */\n\tstatic async addModules(audioContext, moduleId) {\n\t\tconst { audioWorklet } = audioContext;\n\t\tawait addFunctionModule(audioWorklet, getRingBuffer, moduleId);\n\t\tawait addFunctionModule(audioWorklet, getWamEventRingBuffer, moduleId);\n\t\tawait addFunctionModule(audioWorklet, getWamArrayRingBuffer, moduleId);\n\t\tawait addFunctionModule(audioWorklet, getWamParameter, moduleId);\n\t\tawait addFunctionModule(audioWorklet, getWamParameterInfo, moduleId);\n\t\tawait addFunctionModule(audioWorklet, getWamParameterInterpolator, moduleId);\n\t\tawait addFunctionModule(audioWorklet, getWamProcessor, moduleId);\n\t}\n\n\t/**\n\t * @param {WebAudioModule} module\n\t * @param {AudioWorkletNodeOptions} options\n\t */\n\tconstructor(module, options) {\n\t\tconst { audioContext, groupId, moduleId, instanceId } = module;\n\t\toptions.processorOptions = {\n\t\t\tgroupId,\n\t\t\tmoduleId,\n\t\t\tinstanceId,\n\t\t\t...options.processorOptions,\n\t\t};\n\t\tsuper(audioContext, moduleId, options);\n\n\t\t/** @type {WebAudioModule} */\n\t\tthis.module = module;\n\t\t/** @private @type {Set<WamEventType>} */\n\t\tthis._supportedEventTypes = new Set(['wam-automation', 'wam-transport', 'wam-midi', 'wam-sysex', 'wam-mpe', 'wam-osc']);\n\t\t/** @private @type {number} */\n\t\tthis._messageId = 1;\n\t\t/** @private @type {Record<number, (...args: any[]) => any>} */\n\t\tthis._pendingResponses = {};\n\t\t/** @private @type {Record<number, () => any>} */\n\t\tthis._pendingEvents = {};\n\t\t/** @private @type {boolean} */\n\t\tthis._useSab = false; // can override this via processorOptions;\n\t\t/** @private @type {boolean} */\n\t\tthis._eventSabReady = false;\n\t\t/** @private @type {boolean} */\n\t\tthis._destroyed = false;\n\n\t\tthis.port.onmessage = this._onMessage.bind(this);\n\t}\n\n\t/** @returns {string} */\n\tget groupId() { return this.module.groupId; }\n\t/** @returns {string} */\n\tget moduleId() { return this.module.moduleId; }\n\t/** @returns {string} */\n\tget instanceId() { return this.module.instanceId; }\n\n\t/**\n\t * Get parameter info for the specified parameter ids,\n\t * or omit argument to get info for all parameters.\n\t * @param {string[]} parameterIds\n\t * @returns {Promise<WamParameterInfoMap>}\n\t */\n\tasync getParameterInfo(...parameterIds) {\n\t\tconst request = 'get/parameterInfo';\n\t\tconst id = this._generateMessageId();\n\t\treturn new Promise((resolve) => {\n\t\t\tthis._pendingResponses[id] = resolve;\n\t\t\tthis.port.postMessage({\n\t\t\t\tid,\n\t\t\t\trequest,\n\t\t\t\tcontent: { parameterIds },\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Get parameter values for the specified parameter ids,\n\t * or omit argument to get values for all parameters.\n\t * @param {boolean} normalized\n\t * @param {string[]} parameterIds\n\t * @returns {Promise<WamParameterDataMap>}\n\t */\n\tasync getParameterValues(normalized, ...parameterIds) {\n\t\tconst request = 'get/parameterValues';\n\t\tconst id = this._generateMessageId();\n\t\treturn new Promise((resolve) => {\n\t\t\tthis._pendingResponses[id] = resolve;\n\t\t\tthis.port.postMessage({\n\t\t\t\tid,\n\t\t\t\trequest,\n\t\t\t\tcontent: { normalized, parameterIds },\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Set parameter values for the specified parameter ids.\n\t * @param {WamParameterDataMap} parameterValues\n\t * @returns {Promise<void>}\n\t */\n\tasync setParameterValues(parameterValues) {\n\t\tconst request = 'set/parameterValues';\n\t\tconst id = this._generateMessageId();\n\t\treturn new Promise((resolve) => {\n\t\t\tthis._pendingResponses[id] = resolve;\n\t\t\tthis.port.postMessage({\n\t\t\t\tid,\n\t\t\t\trequest,\n\t\t\t\tcontent: { parameterValues },\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Returns an object (such as JSON or a serialized blob)\n\t * that can be used to restore the WAM's state.\n\t * @returns {Promise<any>}\n\t */\n\tasync getState() {\n\t\tconst request = 'get/state';\n\t\t// perhaps the only info to request from processor is param state?\n\t\tconst id = this._generateMessageId();\n\t\treturn new Promise((resolve) => {\n\t\t\tthis._pendingResponses[id] = resolve;\n\t\t\tthis.port.postMessage({ id, request });\n\t\t});\n\t}\n\n\t/**\n\t * Use an object (such as JSON or a serialized blob)\n\t * to restore the WAM's state.\n\t * @param {any} state\n\t */\n\tasync setState(state) {\n\t\tconst request = 'set/state';\n\t\tconst id = this._generateMessageId();\n\t\t// perhaps the only info to send to processor is param state?\n\t\treturn new Promise((resolve) => {\n\t\t\tthis._pendingResponses[id] = resolve;\n\t\t\tthis.port.postMessage({\n\t\t\t\tid,\n\t\t\t\trequest,\n\t\t\t\tcontent: { state },\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Compensation delay hint in seconds.\n\t * @returns {Promise<number>}\n\t */\n\tasync getCompensationDelay() {\n\t\tconst request = 'get/compensationDelay';\n\t\tconst id = this._generateMessageId();\n\t\treturn new Promise((resolve) => {\n\t\t\tthis._pendingResponses[id] = resolve;\n\t\t\tthis.port.postMessage({ id, request });\n\t\t});\n\t}\n\n\t/**\n\t * Register a callback function so it will be called\n\t * when matching events are processed.\n\t * @param {WamEventType} type\n\t * @param {EventListenerOrEventListenerObject | null} callback\n\t * @param {AddEventListenerOptions | boolean} options;\n\t */\n\taddEventListener(type, callback, options) {\n\t\tif (this._supportedEventTypes.has(type)) super.addEventListener(type, callback, options);\n\t}\n\n\t/**\n\t * Deregister a callback function so it will no longer\n\t * be called when matching events are processed.\n\t * @param {WamEventType} type\n\t * @param {EventListenerOrEventListenerObject | null} callback\n\t * @param {AddEventListenerOptions | boolean} options;\n\t */\n\tremoveEventListener(type, callback, options) {\n\t\tif (this._supportedEventTypes.has(type)) super.removeEventListener(type, callback, options);\n\t}\n\n\t/**\n\t * From the main thread, schedule a WamEvent.\n\t * Listeners will be triggered when the event is processed.\n\t * @param {WamEvent[]} events\n\t */\n\tscheduleEvents(...events) {\n\t\tlet i = 0;\n\t\tconst numEvents = events.length;\n\t\tif (this._eventSabReady) {\n\t\t\ti = this._eventWriter.write(...events);\n\t\t\t// fall back on message port if ring buffer gets full\n\t\t}\n\t\twhile (i < numEvents) {\n\t\t\tconst event = events[i];\n\t\t\tconst request = 'add/event';\n\t\t\tconst id = this._generateMessageId();\n\t\t\tlet processed = false;\n\t\t\tnew Promise((resolve, reject) => {\n\t\t\t\tthis._pendingResponses[id] = resolve;\n\t\t\t\tthis._pendingEvents[id] = () => { if (!processed) reject(); };\n\t\t\t\tthis.port.postMessage({\n\t\t\t\t\tid,\n\t\t\t\t\trequest,\n\t\t\t\t\tcontent: { event },\n\t\t\t\t});\n\t\t\t}).then((resolved) => {\n\t\t\t\tprocessed = true;\n\t\t\t\tdelete this._pendingEvents[id];\n\t\t\t\tthis._onEvent(event);\n\t\t\t}).catch((rejected) => { delete this._pendingResponses[id]; });\n\t\t\ti++;\n\t\t}\n\t}\n\n\t/** From the main thread, clear all pending WamEvents. */\n\tasync clearEvents() {\n\t\tconst request = 'remove/events';\n\t\tconst id = this._generateMessageId();\n\t\tconst ids = Object.keys(this._pendingEvents);\n\t\tif (ids.length) {\n\t\t\treturn new Promise((/** @type {(ids: string[]) => any} */resolve) => {\n\t\t\t\tthis._pendingResponses[id] = resolve;\n\t\t\t\tthis.port.postMessage({ id, request });\n\t\t\t}).then((clearedIds) => {\n\t\t\t\tclearedIds.forEach((clearedId) => {\n\t\t\t\t\tthis._pendingEvents[clearedId]();\n\t\t\t\t\tdelete this._pendingEvents[clearedId];\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} toId the instanceId of the destination WAM for the event stream\n\t * @param {number} [output] the event output stream of the source WAM\n\t */\n\tconnectEvents(toId, output) {\n\t\tconst request = 'connect/events';\n\t\tconst id = this._generateMessageId();\n\t\tnew Promise((resolve, reject) => {\n\t\t\tthis._pendingResponses[id] = resolve;\n\t\t\tthis.port.postMessage({\n\t\t\t\tid,\n\t\t\t\trequest,\n\t\t\t\tcontent: { wamInstanceId: toId, output },\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * @param {string} [toId] the instanceId of the destination WAM for the event stream\n\t * @param {number} [output]\n\t */\n\tdisconnectEvents(toId, output) {\n\t\tconst request = 'disconnect/events';\n\t\tconst id = this._generateMessageId();\n\t\tnew Promise((resolve, reject) => {\n\t\t\tthis._pendingResponses[id] = resolve;\n\t\t\tthis.port.postMessage({\n\t\t\t\tid,\n\t\t\t\trequest,\n\t\t\t\tcontent: { wamInstanceId: toId, output },\n\t\t\t});\n\t\t});\n\t}\n\n\t/** Stop processing and remove the node from the graph. */\n\tdestroy() {\n\t\tif (this._audioToMainInterval) clearInterval(this._audioToMainInterval);\n\t\tthis.port.postMessage({ destroy: true });\n\t\tthis.port.close();\n\t\tthis.disconnect();\n\t\tthis._destroyed = true;\n\t}\n\n\t_generateMessageId() {\n\t\t/* eslint-disable-next-line no-plusplus */\n\t\treturn this._messageId++;\n\t}\n\n\t/**\n\t * Post-constructor (asynchronous) initialization method.\n\t */\n\tasync _initialize() {\n\t\tconst request = 'initialize/processor';\n\t\tconst id = this._generateMessageId();\n\t\treturn new Promise((resolve) => {\n\t\t\tthis._pendingResponses[id] = resolve;\n\t\t\tthis.port.postMessage({ id, request });\n\t\t});\n\t}\n\n\t/**\n\t * Messages from audio thread\n\t * @param {MessageEvent} message\n\t * */\n\t_onMessage(message) {\n\t\tconst { data } = message;\n\t\tconst { response, event, eventSab } = data;\n\t\tif (response) {\n\t\t\tconst { id, content } = data;\n\t\t\tconst resolvePendingResponse = this._pendingResponses[id];\n\t\t\tif (resolvePendingResponse) {\n\t\t\t\tdelete this._pendingResponses[id];\n\t\t\t\tresolvePendingResponse(content);\n\t\t\t}\n\t\t\t// else console.log(`unhandled message | response: ${response} content: ${content}`);\n\t\t} else if (eventSab) {\n\t\t\tthis._useSab = true;\n\t\t\tconst { eventCapacity, parameterIds } = eventSab;\n\n\t\t\tif (this._eventSabReady) {\n\t\t\t\t// if parameter set changes after initialization\n\t\t\t\tthis._eventWriter.setParameterIds(parameterIds);\n\t\t\t\tthis._eventReader.setParameterIds(parameterIds);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/** @private @type {SharedArrayBuffer} */\n\t\t\tthis._mainToAudioEventSab = WamEventRingBuffer.getStorageForEventCapacity(RingBuffer,\n\t\t\t\teventCapacity);\n\n\t\t\t/** @private @type {SharedArrayBuffer} */\n\t\t\tthis._audioToMainEventSab = WamEventRingBuffer.getStorageForEventCapacity(RingBuffer,\n\t\t\t\teventCapacity);\n\n\t\t\t/** @private @type {WamEventRingBuffer} */\n\t\t\tthis._eventWriter = new WamEventRingBuffer(RingBuffer, this._mainToAudioEventSab,\n\t\t\t\tparameterIds);\n\t\t\t/** @private @type {WamEventRingBuffer} */\n\t\t\tthis._eventReader = new WamEventRingBuffer(RingBuffer, this._audioToMainEventSab,\n\t\t\t\tparameterIds);\n\n\t\t\tconst request = 'initialize/eventSab';\n\t\t\tconst id = this._generateMessageId();\n\t\t\tnew Promise((resolve, reject) => {\n\t\t\t\tthis._pendingResponses[id] = resolve;\n\t\t\t\tthis.port.postMessage({\n\t\t\t\t\tid,\n\t\t\t\t\trequest,\n\t\t\t\t\tcontent: {\n\t\t\t\t\t\tmainToAudioEventSab: this._mainToAudioEventSab,\n\t\t\t\t\t\taudioToMainEventSab: this._audioToMainEventSab,\n\t\t\t\t\t},\n\t\t\t\t});\n\t\t\t}).then((resolved) => {\n\t\t\t\tthis._eventSabReady = true;\n\n\t\t\t\t// periodically check for messages from audio thread\n\t\t\t\tthis._audioToMainInterval = setInterval(() => {\n\t\t\t\t\tconst events = this._eventReader.read();\n\t\t\t\t\tevents.forEach((e) => { this._onEvent(e); });\n\t\t\t\t}, 100);\n\t\t\t});\n\t\t} else if (event) this._onEvent(event);\n\t}\n\n\t_onEvent(event) {\n\t\tconst { type } = event;\n\t\tthis.dispatchEvent(new CustomEvent(type, {\n\t\t\tbubbles: true,\n\t\t\tdetail: event,\n\t\t}));\n\t}\n}\n", "export default \"2.0.0-alpha.4\";\n", "import apiVersion from './apiVersion.js';\r\nimport addFunctionModule from './addFunctionModule.js';\r\nimport initializeWamEnv from './WamEnv.js';\r\nimport initializeWamGroup from './WamGroup.js';\r\n\r\n/**\r\n * @param {BaseAudioContext} audioContext\r\n * @param {string} [hostGroupId]\r\n * @param {string} [hostGroupKey]\r\n * @returns {Promise<[string, string]>} [hostGroupId, hostGroupKey]\r\n */\r\nconst initializeWamHost = async (audioContext, hostGroupId = `wam-host-${performance.now().toString()}`, hostGroupKey = performance.now().toString()) => {\r\n    await addFunctionModule(audioContext.audioWorklet, initializeWamEnv, apiVersion);\r\n    await addFunctionModule(audioContext.audioWorklet, initializeWamGroup, hostGroupId, hostGroupKey);\r\n    return [hostGroupId, hostGroupKey];\r\n};\r\n\r\nexport default initializeWamHost;\r\n", "import MidiSequencer from \"./index\";\n\nclass MidiSequencerElement extends HTMLElement {\n    module: MidiSequencer;\n    root: ShadowRoot;\n    $slider: HTMLInputElement;\n    $playing: HTMLButtonElement;\n    $rewind: HTMLButtonElement;\n    $now: HTMLSpanElement;\n    $total: HTMLSpanElement;\n    $file: HTMLInputElement;\n    $loop: HTMLInputElement;\n    destroyed: boolean;\n    handleAnimationFrame: () => Promise<void>;\n    $raf: number;\n    constructor(module: MidiSequencer) {\n        super();\n        this.module = module;\n\t\tthis.root = this.attachShadow({ mode: \"open\" });\n\t\tconst $style = document.createElement(\"style\");\n\t\t$style.innerHTML = `\n#time {\n    font-family: monospace;\n}\n`;\n\t\tthis.root.appendChild($style);\n\t\tconst $container = document.createElement(\"div\");\n        $container.classList.add(\"container\");\n        $container.innerHTML = `\n<div>\n    <input type=\"range\" name=\"slider\" id=\"slider\" min=\"0\" max=\"1\" step=\"0.01\">\n    <button id=\"playing\">Start</button>\n    <button id=\"rewind\">Rewind</button>\n    <input type=\"checkbox\" id=\"loop\"><label for=\"loop\">Loop</label>\n</div>\n<div id=\"time\">\n    <span id=\"now\">00:00:00.000</span>\n    <span> / </span>\n    <span id=\"total\">00:00:00.000</span>\n</div>\n<input type=\"file\" name=\"file\" id=\"file\" accept=\".mid, .midi\">\n`;\n\t\tthis.root.appendChild($container);\n        this.$slider = $container.querySelector<HTMLInputElement>(\"#slider\");\n        this.$slider.onchange = () => module.audioNode.goto(+this.$slider.value * module.audioNode.totalDuration);\n        this.$playing = $container.querySelector<HTMLButtonElement>(\"#playing\");\n        this.$playing.onclick = async () => {\n            const { playing } = await module.audioNode.getParameterValues(false, \"playing\");\n            module.audioNode.setParameterValues({ playing: { id: \"playing\", value: +!playing.value, normalized: false } });\n        };\n        this.$rewind = $container.querySelector<HTMLButtonElement>(\"#rewind\");\n        this.$rewind.onclick = () => {\n            module.audioNode.goto(0);\n        };\n        this.$loop = $container.querySelector<HTMLInputElement>(\"#loop\");\n        this.$loop.onchange = () => {\n            module.audioNode.setParameterValues({ loop: { id: \"loop\", value: +this.$loop.checked, normalized: false } });\n        };\n        this.$now = $container.querySelector<HTMLSpanElement>(\"#now\");\n        this.$total = $container.querySelector<HTMLSpanElement>(\"#total\");\n        this.$file = $container.querySelector<HTMLInputElement>(\"#file\");\n        this.$file.onchange = async () => {\n            const file = this.$file.files[0];\n            if (!file) return;\n            const ab = await file.arrayBuffer();\n            module.audioNode.loadFile(ab);\n        };\n        this.destroyed = false;\n        this.handleAnimationFrame = async () => {\n            const { loop, playing } = await module.audioNode.getParameterValues(false, \"loop\", \"playing\");\n            let temp = playing.value.toString();\n            temp = playing.value ? \"Stop\" : \"Start\";\n            if (this.$playing.textContent !== temp) this.$playing.textContent = temp;\n            if (this.$loop.checked !== !!loop.value) this.$loop.checked = !!loop.value;\n            const { timeOffset, totalDuration } = module.audioNode;\n            const date = new Date(timeOffset * 1000);\n            temp = date.toISOString().substring(11, 23);\n            if (this.$now.textContent !== temp) this.$now.textContent = temp;\n            temp = ((timeOffset / totalDuration) || 0).toString();\n            if (this.$slider.value !== temp && this.root.activeElement !== this.$slider) this.$slider.value = temp;\n            date.setTime(totalDuration * 1000);\n            temp = date.toISOString().substring(11, 23);\n            if (this.$total.textContent !== temp) this.$total.textContent = temp;\n            this.$raf = window.requestAnimationFrame(this.handleAnimationFrame);\n        };\n        this.$raf = window.requestAnimationFrame(this.handleAnimationFrame);\n    }\n    destroy() {\n        window.cancelAnimationFrame(this.$raf);\n    }\n}\n\nconst createElement = (module: MidiSequencer) => {\n    const elementId = \"midi-sequencer\";\n    if (!customElements.get(elementId)) {\n        customElements.define(elementId, MidiSequencerElement);\n    }\n    return new MidiSequencerElement(module);\n};\n\nexport default createElement;\n", "// https://github.com/carter-thaxton/midi-file/blob/master/lib/midi-parser.js\n\n// data can be any array-like object.  It just needs to support .length, .slice, and an element getter []\n\nexport type MidiHeader = {\n    format: 0 | 1 | 2;\n    numTracks: number;\n    timeDivision: number;\n} & ({\n    framesPerSecond?: undefined;\n    ticksPerFrame?: undefined;\n    ticksPerBeat: number;\n} | {\n    framesPerSecond: number;\n    ticksPerFrame: number;\n    ticksPerBeat?: undefined;\n});\n\nexport interface MidiData {\n    header: MidiHeader;\n    tracks: MidiEvent[][];\n    duration: number;\n}\n\ntype MidiMetaEventType = \"sequenceNumber\" | \"text\" | \"copyrightNotice\" | \"trackName\" | \"instrumentName\" | \"lyrics\" | \"marker\" | \"cuePoint\" | \"channelPrefix\" | \"portPrefix\" | \"endOfTrack\" | \"setTempo\" | \"smpteOffset\" | \"timeSignature\" | \"keySignature\" | \"sequencerSpecific\" | \"unknownMeta\";\ntype MidiSysExEventType = \"sysEx\" | \"endSysEx\";\ntype MidiChannelEventType = \"noteOn\" | \"noteOff\" | \"noteAftertouch\" | \"controller\" | \"programChange\" | \"channelAftertouch\" | \"pitchBend\";\ntype MidiEventType = MidiMetaEventType | MidiSysExEventType | MidiChannelEventType;\n\nexport interface MidiBaseEvent<T extends MidiEventType> {\n    deltaTicks: number;\n    ticks: number;\n    time: number;\n    type: T;\n}\nexport interface MidiMetaEvent<T extends MidiMetaEventType> extends MidiBaseEvent<T> {\n    meta: true;\n}\nexport interface MidiChannelEvent<T extends MidiChannelEventType> extends MidiBaseEvent<T> {\n    running?: true;\n    channel: number;\n    time: number;\n    bytes: Uint8Array;\n}\nexport interface MidiSequenceNumberEvent extends MidiMetaEvent<\"sequenceNumber\"> {\n    type: \"sequenceNumber\";\n    number: number;\n}\nexport interface MidiTextEvent extends MidiMetaEvent<\"text\"> {\n    text: string;\n}\nexport interface MidiCopyrightNoticeEvent extends MidiMetaEvent<\"copyrightNotice\"> {\n    text: string;\n}\nexport interface MidiTrackNameEvent extends MidiMetaEvent<\"trackName\"> {\n    text: string;\n}\nexport interface MidiInstrumentNameEvent extends MidiMetaEvent<\"instrumentName\"> {\n    text: string;\n}\nexport interface MidiLyricsEvent extends MidiMetaEvent<\"lyrics\"> {\n    text: string;\n}\nexport interface MidiMarkerEvent extends MidiMetaEvent<\"marker\"> {\n    text: string;\n}\nexport interface MidiCuePointEvent extends MidiMetaEvent<\"cuePoint\"> {\n    text: string;\n}\nexport interface MidiChannelPrefixEvent extends MidiMetaEvent<\"channelPrefix\"> {\n    channel: number;\n}\nexport interface MidiPortPrefixEvent extends MidiMetaEvent<\"portPrefix\"> {\n    port: number;\n}\nexport interface MidiEndOfTrackEvent extends MidiMetaEvent<\"endOfTrack\"> {\n}\nexport interface MidiSetTempoEvent extends MidiMetaEvent<\"setTempo\"> {\n    microsecondsPerBeat: number;\n}\nexport interface MidiSmpteOffsetEvent extends MidiMetaEvent<\"smpteOffset\"> {\n    frameRate: number;\n    hour: number;\n    min: number;\n    sec: number;\n    frame: number;\n    subFrame: number;\n}\nexport interface MidiTimeSignatureEvent extends MidiMetaEvent<\"timeSignature\"> {\n    numerator: number;\n    denominator: number;\n    metronome: number;\n    thirtyseconds: number;\n}\nexport interface MidiKeySignatureEvent extends MidiMetaEvent<\"keySignature\"> {\n    key: number;\n    scale: number;\n}\nexport interface MidiSequencerSpecificEvent extends MidiMetaEvent<\"sequencerSpecific\"> {\n    data: number;\n}\nexport interface MidiUnknownMetaEvent extends MidiMetaEvent<\"unknownMeta\"> {\n    data: number;\n    metatypeByte: number;\n}\nexport interface MidiSysExEvent extends MidiBaseEvent<\"sysEx\"> {\n    bytes: Uint8Array;\n}\nexport interface MidiEndSysExEvent extends MidiBaseEvent<\"endSysEx\"> {\n    bytes: Uint8Array;\n}\nexport interface MidiNoteOffEvent extends MidiChannelEvent<\"noteOff\"> {\n    velocity: number;\n    byte9?: boolean;\n}\nexport interface MidiNoteOnEvent extends MidiChannelEvent<\"noteOn\"> {\n    velocity: number;\n}\nexport interface MidiNoteAftertouchEvent extends MidiChannelEvent<\"noteAftertouch\"> {\n    noteNumber: number;\n    amount: number;\n}\nexport interface MidiControllerEvent extends MidiChannelEvent<\"controller\"> {\n    controllerType: number;\n    value: number;\n}\nexport interface MidiProgramChangeEvent extends MidiChannelEvent<\"programChange\"> {\n    programNumber: number;\n}\nexport interface MidiChannelAftertouchEvent extends MidiChannelEvent<\"channelAftertouch\"> {\n    amount: number;\n}\nexport interface MidiPitchBendEvent extends MidiChannelEvent<\"pitchBend\"> {\n    value: number;\n}\n\nexport type MidiEvent =\n    | MidiSequenceNumberEvent\n    | MidiTextEvent\n    | MidiCopyrightNoticeEvent\n    | MidiTrackNameEvent\n    | MidiInstrumentNameEvent\n    | MidiLyricsEvent\n    | MidiMarkerEvent\n    | MidiCuePointEvent\n    | MidiChannelPrefixEvent\n    | MidiPortPrefixEvent\n    | MidiEndOfTrackEvent\n    | MidiSetTempoEvent\n    | MidiSmpteOffsetEvent\n    | MidiTimeSignatureEvent\n    | MidiKeySignatureEvent\n    | MidiSequencerSpecificEvent\n    | MidiUnknownMetaEvent\n    | MidiSysExEvent\n    | MidiEndSysExEvent\n    | MidiControllerEvent\n    | MidiProgramChangeEvent\n    | MidiChannelAftertouchEvent\n    | MidiPitchBendEvent\n    | MidiNoteAftertouchEvent\n    | MidiNoteOnEvent\n    | MidiNoteOffEvent;\n\nclass Parser {\n    bufferLen: number;\n    buffer: DataView;\n    pos: number;\n    constructor(data: ArrayBuffer) {\n        this.buffer = new DataView(data);\n        this.bufferLen = this.buffer.byteLength;\n        this.pos = 0;\n    }\n    eof() {\n        return this.pos >= this.bufferLen;\n    }\n    readUInt8() {\n        const result = this.buffer.getUint8(this.pos);\n        this.pos += 1;\n        return result;\n    }\n    readInt8() {\n        const result = this.buffer.getInt8(this.pos);\n        this.pos += 1;\n        return result;\n    }\n    readUInt16() {\n        const result = this.buffer.getUint16(this.pos);\n        this.pos += 2;\n        return result;\n    }\n    readInt16() {\n        const result = this.buffer.getInt16(this.pos);\n        this.pos += 2;\n        return result;\n    }\n    readUInt24() {\n        const b0 = this.readUInt8();\n        const b1 = this.readUInt8();\n        const b2 = this.readUInt8();\n    \n        return (b0 << 16) + (b1 << 8) + b2;\n    }\n    readInt24() {\n        const u = this.readUInt24()\n        if (u & 0x800000) return u - 0x1000000;\n        else return u;\n    }\n    readUInt32() {\n        const result = this.buffer.getUint32(this.pos);\n        this.pos += 4;\n        return result;\n    }\n    readInt32() {\n        const result = this.buffer.getInt32(this.pos);\n        this.pos += 4;\n        return result;\n    }\n    readBytes(len: number) {\n        const bytes = this.buffer.buffer.slice(this.pos, this.pos + len);\n        this.pos += len;\n        return bytes;\n    }\n    readString(len: number) {\n        const bytes = this.readBytes(len);\n        return String.fromCharCode.apply(null, new Uint8Array(bytes));\n    }\n    readVarInt() {\n        let result = 0;\n        while (!this.eof()) {\n            const b = this.readUInt8();\n            if (b & 0x80) {\n                result += (b & 0x7f);\n                result <<= 7;\n            } else {\n                // b is last byte\n                return result + b;\n            }\n        }\n        // premature eof\n        return result;\n    }\n    readChunk() {\n        const id = this.readString(4);\n        const length = this.readUInt32();\n        const data = this.readBytes(length);\n        return { id, length, data };\n    }\n}\n\nconst parseMidi = (data: ArrayBuffer): MidiData => {\n    const p = new Parser(data);\n\n    const headerChunk = p.readChunk();\n    if (headerChunk.id != \"MThd\")\n        throw new Error(`Bad MIDI file.  Expected \"MHdr\", got: \"${headerChunk.id}\"`);\n    const header = parseHeader(headerChunk.data);\n\n    const tracks = [];\n    let duration = 0;\n    for (let i = 0; !p.eof() && i < header.numTracks; i++) {\n        const trackChunk = p.readChunk();\n        if (trackChunk.id != \"MTrk\")\n            throw new Error(`Bad MIDI file.  Expected \"MTrk\", got: \"${trackChunk.id}\"`);\n        const track = parseTrack(trackChunk.data, header.ticksPerBeat);\n        tracks.push(track);\n        const lastEvent = track[track.length - 1] as MidiChannelEvent<any>;\n        if (\"time\" in lastEvent && lastEvent.time > duration) duration = lastEvent.time;\n    }\n    return { header, tracks, duration };\n}\n\nconst parseHeader = (data: ArrayBuffer): MidiHeader => {\n    const p = new Parser(data);\n\n    const format = p.readUInt16() as 0 | 1 | 2;\n    const numTracks = p.readUInt16();\n\n    const timeDivision = p.readUInt16();\n    if (timeDivision & 0x8000) {\n        const framesPerSecond = 0x100 - (timeDivision >> 8);\n        const ticksPerFrame = timeDivision & 0xFF;\n        return { format, numTracks, timeDivision, framesPerSecond, ticksPerFrame };\n    } else {\n        const ticksPerBeat = timeDivision;\n        return { format, numTracks, timeDivision, ticksPerBeat };\n    }\n}\n\nconst parseTrack = (data: ArrayBuffer, ppq = 480) => {\n    const p = new Parser(data);\n\n    let lastEventTypeByte: number = null;\n\n    let ticks = 0;\n    let bpm = 120;\n    let tempoTicks = 0;\n    let tempoTime = 0;\n\n    const readEvent = (): MidiEvent => {\n        const deltaTicks = p.readVarInt();\n        ticks += deltaTicks;\n        const elapsedBeats = (ticks - tempoTicks) / ppq;\n        const time = tempoTime + (60 / bpm) * elapsedBeats;\n\n        let eventTypeByte = p.readUInt8();\n\n        const event: any = { ticks, deltaTicks, time };\n\n        if ((eventTypeByte & 0xf0) === 0xf0) {\n            // system / meta event\n            if (eventTypeByte === 0xff) {\n                // meta event\n                event.meta = true;\n                const metatypeByte = p.readUInt8();\n                const length = p.readVarInt();\n                if (metatypeByte === 0x00) {\n                    event.type = \"sequenceNumber\";\n                    if (length !== 2) throw `Expected length for sequenceNumber event is 2, got ${length}`;\n                    event.number = p.readUInt16();\n                } else if (metatypeByte === 0x01) {\n                    event.type = \"text\";\n                    event.text = p.readString(length);\n                } else if (metatypeByte === 0x02) {\n                    event.type = \"copyrightNotice\";\n                    event.text = p.readString(length);\n                } else if (metatypeByte === 0x03) {\n                    event.type = \"trackName\";\n                    event.text = p.readString(length);\n                } else if (metatypeByte === 0x04) {\n                    event.type = \"instrumentName\";\n                    event.text = p.readString(length);\n                } else if (metatypeByte === 0x05) {\n                    event.type = \"lyrics\";\n                    event.text = p.readString(length);\n                } else if (metatypeByte === 0x06) {\n                    event.type = \"marker\";\n                    event.text = p.readString(length);\n                } else if (metatypeByte === 0x07) {\n                    event.type = \"cuePoint\";\n                    event.text = p.readString(length);\n                } else if (metatypeByte === 0x20) {\n                    event.type = \"channelPrefix\";\n                    if (length != 1) throw new Error(`Expected length for channelPrefix event is 1, got ${length}`);\n                    event.channel = p.readUInt8();\n                } else if (metatypeByte === 0x21) {\n                    event.type = \"portPrefix\";\n                    if (length != 1) throw new Error(`Expected length for portPrefix event is 1, got ${length}`);\n                    event.port = p.readUInt8();\n                } else if (metatypeByte === 0x2f) {\n                    event.type = \"endOfTrack\";\n                    if (length != 0) throw new Error(`Expected length for endOfTrack event is 0, got ${length}`);\n                } else if (metatypeByte === 0x51) {\n                    event.type = \"setTempo\";\n                    if (length != 3) throw new Error(`Expected length for setTempo event is 3, got ${length}`);\n                    const microsecondsPerBeat = p.readUInt24();\n                    event.microsecondsPerBeat = microsecondsPerBeat;\n                    bpm = 60000000 / event.microsecondsPerBeat;\n                    tempoTicks = ticks;\n                    tempoTime = time;\n                } else if (metatypeByte === 0x54) {\n                    event.type = \"smpteOffset\";\n                    if (length != 5) throw new Error(`Expected length for smpteOffset event is 5, got ${length}`);\n                    const hourByte = p.readUInt8();\n                    const FRAME_RATES: Record<number, number> = { 0x00: 24, 0x20: 25, 0x40: 29, 0x60: 30 };\n                    event.frameRate = FRAME_RATES[hourByte & 0x60];\n                    event.hour = hourByte & 0x1f;\n                    event.min = p.readUInt8();\n                    event.sec = p.readUInt8();\n                    event.frame = p.readUInt8();\n                    event.subFrame = p.readUInt8();\n                } else if (metatypeByte === 0x58) {\n                    event.type = \"timeSignature\";\n                    if (length != 4) throw new Error(`Expected length for timeSignature event is 4, got ${length}`);\n                    event.numerator = p.readUInt8();\n                    event.denominator = (1 << p.readUInt8());\n                    event.metronome = p.readUInt8();\n                    event.thirtyseconds = p.readUInt8();\n                } else if (metatypeByte === 0x59) {\n                    event.type = \"keySignature\";\n                    if (length != 2) throw new Error(`Expected length for keySignature event is 2, got ${length}`);\n                    event.key = p.readInt8();\n                    event.scale = p.readUInt8();\n                } else if (metatypeByte === 0x7f) {\n                    event.type = \"sequencerSpecific\";\n                    event.data = p.readBytes(length);\n                } else {\n                    event.type = \"unknownMeta\";\n                    event.data = p.readBytes(length);\n                    event.metatypeByte = metatypeByte;\n                }\n            } else if (eventTypeByte == 0xf0) {\n                event.type = \"sysEx\";\n                const length = p.readVarInt();\n                const data = p.readBytes(length);\n                event.bytes = new Uint8Array([eventTypeByte, ...new Uint8Array(data)]);\n            } else if (eventTypeByte == 0xf7) {\n                event.type = \"endSysEx\";\n                const length = p.readVarInt();\n                const data = p.readBytes(length);\n                event.bytes = new Uint8Array([eventTypeByte, ...new Uint8Array(data)]);\n            } else {\n                throw new Error(`Unrecognised MIDI event type byte: ${eventTypeByte}`);\n            }\n        } else {\n            // channel event\n            let param1: number;\n            if ((eventTypeByte & 0x80) === 0) {\n                // running status - reuse lastEventTypeByte as the event type.\n                // eventTypeByte is actually the first parameter\n                if (lastEventTypeByte === null) throw new Error(\"Running status byte encountered before status byte\");\n                param1 = eventTypeByte;\n                eventTypeByte = lastEventTypeByte;\n                event.running = true;\n            } else {\n                param1 = p.readUInt8();\n                lastEventTypeByte = eventTypeByte;\n            }\n            const eventType = eventTypeByte >> 4;\n            event.channel = eventTypeByte & 0x0f;\n            if (eventType === 0x08) {\n                event.type = \"noteOff\";\n                event.noteNumber = param1;\n                const param2 = p.readUInt8();\n                event.velocity = param2;\n                event.bytes = new Uint8Array([eventTypeByte, param1, param2]);\n            } else if (eventType === 0x09) {\n                const velocity = p.readUInt8();\n                event.type = velocity === 0 ? \"noteOff\" : \"noteOn\";\n                event.noteNumber = param1;\n                event.velocity = velocity;\n                if (velocity === 0) event.byte9 = true;\n                event.bytes = new Uint8Array([eventTypeByte, param1, velocity]);\n            } else if (eventType === 0x0a) {\n                event.type = \"noteAftertouch\";\n                event.noteNumber = param1;\n                const param2 = p.readUInt8();\n                event.amount = param2;\n                event.bytes = new Uint8Array([eventTypeByte, param1, param2]);\n            } else if (eventType === 0x0b) {\n                event.type = \"controller\";\n                event.controllerType = param1;\n                const param2 = p.readUInt8();\n                event.value = param2;\n                event.bytes = new Uint8Array([eventTypeByte, param1, param2]);\n            } else if (eventType === 0x0c) {\n                event.type = \"programChange\";\n                event.programNumber = param1;\n                event.bytes = new Uint8Array([eventTypeByte, param1]);\n            } else if (eventType === 0x0d) {\n                event.type = \"channelAftertouch\";\n                event.amount = param1;\n                event.bytes = new Uint8Array([eventTypeByte, param1]);\n            } else if (eventType === 0x0e) {\n                event.type = \"pitchBend\";\n                const param2 = p.readUInt8();\n                event.value = (param1 + (param2 << 7)) - 0x2000;\n                event.bytes = new Uint8Array([eventTypeByte, param1, param2]);\n            } else {\n                throw new Error(`Unrecognised MIDI event type: ${eventType}`);\n            }\n        }\n        return event;\n    }\n    const events = [];\n    while (!p.eof()) {\n        const event = readEvent();\n        events.push(event);\n    }\n    return events;\n}\n\nexport default parseMidi;\n", "import type { WamParameterInfoMap } from \"@webaudiomodules/api\";\nimport type { WamSDKBaseModuleScope } from \"@webaudiomodules/sdk\";\nimport type { AudioWorkletGlobalScope, TypedMessageEvent } from \"@webaudiomodules/sdk-parammgr\";\nimport type { MidiChannelEvent, MidiData } from \"./MidiParser\";\n\nexport type Parameters = \"playing\" | \"loop\";\nexport type MsgIn = { type: \"midiJson\"; data: MidiData } | { type: \"goto\"; data: number };\nexport type MsgOut = { type: \"timeOffset\"; data: number };\nconst getMidiSequencerProcessor = (moduleId?: string) => {\n    const audioWorkletGlobalScope = globalThis as unknown as AudioWorkletGlobalScope;\n    const { registerProcessor, sampleRate } = audioWorkletGlobalScope;\n\n\tconst ModuleScope: WamSDKBaseModuleScope = audioWorkletGlobalScope.webAudioModules.getModuleScope(moduleId);\n\tconst {\n\t\tWamProcessor,\n\t\tWamParameterInfo,\n\t} = ModuleScope;\n\n    class MidiSequencerProcessor extends WamProcessor {\n        _generateWamParameterInfo(): WamParameterInfoMap {\n            return {\n                playing: new WamParameterInfo(\"playing\", {\n\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\tlabel: \"Playing\",\n                    minValue: 0,\n                    maxValue: 1,\n                    defaultValue: 0\n                }),\n                loop: new WamParameterInfo(\"loop\", {\n\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\tlabel: \"Loop\",\n                    minValue: 0,\n                    maxValue: 1,\n                    defaultValue: 0\n                })\n            };\n        }\n        playing = false;\n        loop = false;\n        data: MidiData = null;\n        orderedEvents: { data: Uint8Array; time: number }[] = [];\n        $event = 0;\n        timeOffset = 0;\n        totalDuration = 0;\n        handleMessage: (e: TypedMessageEvent<MsgIn>) => any;\n        constructor(options: AudioWorkletNodeOptions) {\n            super(options);\n            this.handleMessage = (e) => {\n                if (e.data.type === \"midiJson\") {\n                    this.setData(e.data.data);\n                } else if (e.data.type === \"goto\") {\n                    this.goto(e.data.data);\n                }\n            };\n            this.port.addEventListener(\"message\", this.handleMessage);\n        }\n        setData(data: MidiData) {\n            this.sendFlush();\n            this.data = data;\n            this.orderedEvents = [];\n            this.$event = 0;\n            this.timeOffset = 0;\n            this.totalDuration = data.duration;\n            data.tracks.forEach((track) => {\n                track.forEach((event: MidiChannelEvent<any>) => {\n                    if (event.bytes) {\n                        this.orderedEvents.push({ time: event.time, data: event.bytes });\n                    }\n                })\n            });\n            this.orderedEvents.sort((a, b) => a.time - b.time);\n        }\n        goto(time: number) {\n            this.sendFlush();\n            let $ = 0;\n            this.timeOffset = Math.min(time, this.totalDuration);\n            for (let i = 0; i < this.orderedEvents.length; i++) {\n                const event = this.orderedEvents[i];\n                if (event.time < this.timeOffset) $ = i;\n                else break;\n            }\n            this.$event = $;\n        }\n        onMidi(data: Uint8Array | number[], time: number) {\n            this.emitEvents({ type: \"wam-midi\", data: { bytes: [...data] as [number, number, number] }, time })\n        }\n        sendFlush() {\n            const { currentTime } = audioWorkletGlobalScope;\n            this.onMidi([176, 121, 0], currentTime); // All Controllers Reset\n            this.onMidi([176, 123, 0], currentTime); // All Notes Off\n        }\n        advance(offset: number, playing: boolean, loop: boolean, fromTime: number) {\n            if (!playing) return;\n            if (this.timeOffset >= this.totalDuration) {\n                if (loop) {\n                    this.timeOffset = 0;\n                    this.$event = 0;\n                } else return;\n            }\n            if (!this.orderedEvents.length) return;\n            let advanced = 0;\n            while (advanced < offset) {\n                let $ = this.$event + 1;\n                let nextEventDeltaTime = 0;\n                let nextEvent = null;\n                const timeOffset = this.timeOffset + advanced;\n                if ($ >= this.orderedEvents.length) {\n                    nextEventDeltaTime += this.totalDuration - timeOffset;\n                    if (loop) {\n                        $ = 0;\n                        nextEvent = this.orderedEvents[$];\n                        const { time } = nextEvent;\n                        this.timeOffset -= this.totalDuration;\n                        nextEventDeltaTime += time;\n                    }\n                } else {\n                    nextEvent = this.orderedEvents[$];\n                    const { time } = nextEvent;\n                    nextEventDeltaTime += time - timeOffset;\n                }\n                if (advanced + nextEventDeltaTime < offset) {\n                    if (nextEvent) {\n                        const { data } = nextEvent;\n                        this.onMidi(data, fromTime + advanced);\n                    } else break;\n                    this.$event = $;\n                }\n                advanced += nextEventDeltaTime;\n            }\n            this.timeOffset += offset;\n            if (loop) {\n                this.timeOffset %= this.totalDuration;\n            } else if (this.timeOffset > this.totalDuration) {\n                this.timeOffset = this.totalDuration;\n            }\n        }\n        updateTime() {\n            this.port.postMessage({ type: \"timeOffset\", data: this.timeOffset });\n        }\n\t\t_process(startSample: number, endSample: number, inputs: Float32Array[][], outputs: Float32Array[][], parameters: Record<string, Float32Array>) {\n            const advanceTime = (endSample - startSample) / sampleRate;\n            const { currentTime } = audioWorkletGlobalScope;\n            const fromTime = currentTime + startSample / sampleRate;\n            const playing = !!this._parameterInterpolators.playing.values[startSample];\n            if (playing !== this.playing && !playing) this.onMidi([176, 123, 0], currentTime); // All Notes Off\n            this.playing = playing;\n            this.loop = !!this._parameterInterpolators.loop.values[startSample];\n            this.advance(advanceTime, this.playing, this.loop, fromTime);\n            this.updateTime();\n            return true;\n        }\n    }\n    try {\n        registerProcessor(moduleId, MidiSequencerProcessor)\n    } catch (error) {\n        console.warn(error);\n    }\n    return MidiSequencerProcessor;\n};\n\nexport default getMidiSequencerProcessor;\n", "import { WamNode, addFunctionModule, WebAudioModule } from \"@webaudiomodules/sdk\";\nimport { TypedAudioWorkletNode, TypedAudioWorkletNodeOptions } from \"@webaudiomodules/sdk-parammgr\";\nimport parseMidi from \"./MidiParser\";\nimport getMidiSequencerProcessor, { MsgIn as MsgOut, MsgOut as MsgIn, Parameters } from \"./MidiSequencerProcessor\";\n\nclass MidiSequencerNode extends WamNode implements TypedAudioWorkletNode<MsgIn, MsgOut> {\n    static async addModules(context: BaseAudioContext, moduleId: string) {\n\t\tconst { audioWorklet } = context;\n\t\tawait super.addModules(context, moduleId);\n\t\tawait addFunctionModule(audioWorklet, getMidiSequencerProcessor, moduleId);\n\t}\n    timeOffset: number;\n    totalDuration: number;\n    handleMessage: (e: MessageEvent<MsgIn>) => void;\n    constructor(module: WebAudioModule<MidiSequencerNode>, options: TypedAudioWorkletNodeOptions) {\n\t\toptions.processorOptions = {\n            ...options.processorOptions,\n\t\t\tnumberOfInputs: 0,\n\t\t\tnumberOfOutputs: 1,\n\t\t};\n        super(module, options);\n        this.timeOffset = 0;\n        this.totalDuration = 0;\n        this.handleMessage = (e) => {\n            if (e.data.type === \"timeOffset\") {\n                this.timeOffset = e.data.data;\n            }\n        };\n\t\tthis.port.addEventListener(\"message\", this.handleMessage);\n    }\n    loadFile(file: ArrayBuffer) {\n        const data = parseMidi(file);\n        this.totalDuration = data.duration;\n        this.port.postMessage({ type: \"midiJson\", data });\n    }\n    goto(time: number) {\n        this.port.postMessage({ type: \"goto\", data: time });\n    }\n\tdestroy() {\n\t\tthis.port.removeEventListener(\"message\", this.handleMessage);\n\t\tsuper.destroy();\n\t}\n}\n\nexport default MidiSequencerNode;\n", "import { WebAudioModule } from \"@webaudiomodules/sdk\";\nimport createElement from \"./gui\";\nimport MidiSequencerNode from \"./MidiSequencerNode\";\n\nconst getBaseUrl = (relativeUrl: URL) => {\n\tconst baseUrl = relativeUrl.href.substring(0, relativeUrl.href.lastIndexOf(\"/\"));\n\treturn baseUrl;\n};\n\nclass MidiSequencer extends WebAudioModule<MidiSequencerNode> {\n\t_baseUrl = getBaseUrl(new URL(\".\", import.meta.url));\n\t_descriptorUrl = `${this._baseUrl}/descriptor.json`;\n\tasync createAudioNode(initialState: any) {\n\t\tawait MidiSequencerNode.addModules(this.audioContext, this.moduleId);\n\t\tconst node: MidiSequencerNode = new MidiSequencerNode(this, {});\n\t\tawait node._initialize();\n\n\t\t// Set initial state if applicable\n\t\tif (initialState) node.setState(initialState);\n\n\t\treturn node;\n\t}\n\tasync createGui() {\n\t\treturn createElement(this);\n\t}\n}\n\nexport default MidiSequencer;\n"],
  "mappings": "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",
  "names": []
}
